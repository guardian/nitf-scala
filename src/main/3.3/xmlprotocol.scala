// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package com.gu.nitf.scalaxb

import scala.concurrent.Future


/**
usage:
val obj = scalaxb.fromXML[com.gu.nitf.scalaxb.Foo](node)
val document = scalaxb.toXML[com.gu.nitf.scalaxb.Foo](obj, "foo", com.gu.nitf.scalaxb.defaultScope)
**/
object `package` extends XMLProtocol { }

trait XMLProtocol extends scalaxb.XMLStandardTypes {
  val defaultScope = scalaxb.toScope(Some("nitf") -> "http://iptc.org/std/nitf/2006-03-01/",
    Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val Comgunitfmodel_AlignFormat: scalaxb.XMLFormat[com.gu.nitf.model.Align] = new DefaultComgunitfmodel_AlignFormat {}
  implicit lazy val Comgunitfmodel_ValignFormat: scalaxb.XMLFormat[com.gu.nitf.model.Valign] = new DefaultComgunitfmodel_ValignFormat {}
  implicit lazy val Comgunitfmodel_NitfFormat: scalaxb.XMLFormat[com.gu.nitf.model.Nitf] = new DefaultComgunitfmodel_NitfFormat {}
  implicit lazy val Comgunitfmodel_HeadFormat: scalaxb.XMLFormat[com.gu.nitf.model.Head] = new DefaultComgunitfmodel_HeadFormat {}
  implicit lazy val Comgunitfmodel_TypeFormat: scalaxb.XMLFormat[com.gu.nitf.model.Type] = new DefaultComgunitfmodel_TypeFormat {}
  implicit lazy val Comgunitfmodel_TitleFormat: scalaxb.XMLFormat[com.gu.nitf.model.Title] = new DefaultComgunitfmodel_TitleFormat {}
  implicit lazy val Comgunitfmodel_MetaFormat: scalaxb.XMLFormat[com.gu.nitf.model.Meta] = new DefaultComgunitfmodel_MetaFormat {}
  implicit lazy val Comgunitfmodel_TobjectFormat: scalaxb.XMLFormat[com.gu.nitf.model.Tobject] = new DefaultComgunitfmodel_TobjectFormat {}
  implicit lazy val Comgunitfmodel_TobjectPropertyFormat: scalaxb.XMLFormat[com.gu.nitf.model.TobjectProperty] = new DefaultComgunitfmodel_TobjectPropertyFormat {}
  implicit lazy val Comgunitfmodel_TobjectSubjectFormat: scalaxb.XMLFormat[com.gu.nitf.model.TobjectSubject] = new DefaultComgunitfmodel_TobjectSubjectFormat {}
  implicit lazy val Comgunitfmodel_IimFormat: scalaxb.XMLFormat[com.gu.nitf.model.Iim] = new DefaultComgunitfmodel_IimFormat {}
  implicit lazy val Comgunitfmodel_DsFormat: scalaxb.XMLFormat[com.gu.nitf.model.Ds] = new DefaultComgunitfmodel_DsFormat {}
  implicit lazy val Comgunitfmodel_DocdataFormat: scalaxb.XMLFormat[com.gu.nitf.model.Docdata] = new DefaultComgunitfmodel_DocdataFormat {}
  implicit lazy val Comgunitfmodel_CorrectionFormat: scalaxb.XMLFormat[com.gu.nitf.model.Correction] = new DefaultComgunitfmodel_CorrectionFormat {}
  implicit lazy val Comgunitfmodel_EvlocFormat: scalaxb.XMLFormat[com.gu.nitf.model.Evloc] = new DefaultComgunitfmodel_EvlocFormat {}
  implicit lazy val Comgunitfmodel_DocIdFormat: scalaxb.XMLFormat[com.gu.nitf.model.DocId] = new DefaultComgunitfmodel_DocIdFormat {}
  implicit lazy val Comgunitfmodel_DelListFormat: scalaxb.XMLFormat[com.gu.nitf.model.DelList] = new DefaultComgunitfmodel_DelListFormat {}
  implicit lazy val Comgunitfmodel_DelListSequence1Format: scalaxb.XMLFormat[com.gu.nitf.model.DelListSequence1] = new DefaultComgunitfmodel_DelListSequence1Format {}
  implicit lazy val Comgunitfmodel_FromSrcFormat: scalaxb.XMLFormat[com.gu.nitf.model.FromSrc] = new DefaultComgunitfmodel_FromSrcFormat {}
  implicit lazy val Comgunitfmodel_UrgencyFormat: scalaxb.XMLFormat[com.gu.nitf.model.Urgency] = new DefaultComgunitfmodel_UrgencyFormat {}
  implicit lazy val Comgunitfmodel_FixtureFormat: scalaxb.XMLFormat[com.gu.nitf.model.Fixture] = new DefaultComgunitfmodel_FixtureFormat {}
  implicit lazy val Comgunitfmodel_DateIssueFormat: scalaxb.XMLFormat[com.gu.nitf.model.DateIssue] = new DefaultComgunitfmodel_DateIssueFormat {}
  implicit lazy val Comgunitfmodel_DateReleaseFormat: scalaxb.XMLFormat[com.gu.nitf.model.DateRelease] = new DefaultComgunitfmodel_DateReleaseFormat {}
  implicit lazy val Comgunitfmodel_DateExpireFormat: scalaxb.XMLFormat[com.gu.nitf.model.DateExpire] = new DefaultComgunitfmodel_DateExpireFormat {}
  implicit lazy val Comgunitfmodel_DocScopeFormat: scalaxb.XMLFormat[com.gu.nitf.model.DocScope] = new DefaultComgunitfmodel_DocScopeFormat {}
  implicit lazy val Comgunitfmodel_SeriesFormat: scalaxb.XMLFormat[com.gu.nitf.model.Series] = new DefaultComgunitfmodel_SeriesFormat {}
  implicit lazy val Comgunitfmodel_EdMsgFormat: scalaxb.XMLFormat[com.gu.nitf.model.EdMsg] = new DefaultComgunitfmodel_EdMsgFormat {}
  implicit lazy val Comgunitfmodel_DuKeyFormat: scalaxb.XMLFormat[com.gu.nitf.model.DuKey] = new DefaultComgunitfmodel_DuKeyFormat {}
  implicit lazy val Comgunitfmodel_DocCopyrightFormat: scalaxb.XMLFormat[com.gu.nitf.model.DocCopyright] = new DefaultComgunitfmodel_DocCopyrightFormat {}
  implicit lazy val Comgunitfmodel_DocRightsFormat: scalaxb.XMLFormat[com.gu.nitf.model.DocRights] = new DefaultComgunitfmodel_DocRightsFormat {}
  implicit lazy val Comgunitfmodel_KeyListFormat: scalaxb.XMLFormat[com.gu.nitf.model.KeyList] = new DefaultComgunitfmodel_KeyListFormat {}
  implicit lazy val Comgunitfmodel_KeyListSequence1Format: scalaxb.XMLFormat[com.gu.nitf.model.KeyListSequence1] = new DefaultComgunitfmodel_KeyListSequence1Format {}
  implicit lazy val Comgunitfmodel_KeywordFormat: scalaxb.XMLFormat[com.gu.nitf.model.Keyword] = new DefaultComgunitfmodel_KeywordFormat {}
  implicit lazy val Comgunitfmodel_IdentifiedContentFormat: scalaxb.XMLFormat[com.gu.nitf.model.IdentifiedContent] = new DefaultComgunitfmodel_IdentifiedContentFormat {}
  implicit lazy val Comgunitfmodel_TypeTypeFormat: scalaxb.XMLFormat[com.gu.nitf.model.TypeType] = new DefaultComgunitfmodel_TypeTypeFormat {}
  implicit lazy val Comgunitfmodel_PubdataFormat: scalaxb.XMLFormat[com.gu.nitf.model.Pubdata] = new DefaultComgunitfmodel_PubdataFormat {}
  implicit lazy val Comgunitfmodel_FunctionTypeTypeFormat: scalaxb.XMLFormat[com.gu.nitf.model.FunctionTypeType] = new DefaultComgunitfmodel_FunctionTypeTypeFormat {}
  implicit lazy val Comgunitfmodel_RevisionHistoryFormat: scalaxb.XMLFormat[com.gu.nitf.model.RevisionHistory] = new DefaultComgunitfmodel_RevisionHistoryFormat {}
  implicit lazy val Comgunitfmodel_BodyFormat: scalaxb.XMLFormat[com.gu.nitf.model.Body] = new DefaultComgunitfmodel_BodyFormat {}
  implicit lazy val Comgunitfmodel_BodyHeadFormat: scalaxb.XMLFormat[com.gu.nitf.model.BodyHead] = new DefaultComgunitfmodel_BodyHeadFormat {}
  implicit lazy val Comgunitfmodel_HedlineFormat: scalaxb.XMLFormat[com.gu.nitf.model.Hedline] = new DefaultComgunitfmodel_HedlineFormat {}
  implicit lazy val Comgunitfmodel_Hl1Format: scalaxb.XMLFormat[com.gu.nitf.model.Hl1] = new DefaultComgunitfmodel_Hl1Format {}
  implicit lazy val Comgunitfmodel_Hl2Format: scalaxb.XMLFormat[com.gu.nitf.model.Hl2] = new DefaultComgunitfmodel_Hl2Format {}
  implicit lazy val Comgunitfmodel_NoteclassFormat: scalaxb.XMLFormat[com.gu.nitf.model.Noteclass] = new DefaultComgunitfmodel_NoteclassFormat {}
  implicit lazy val Comgunitfmodel_TypeType2Format: scalaxb.XMLFormat[com.gu.nitf.model.TypeType2] = new DefaultComgunitfmodel_TypeType2Format {}
  implicit lazy val Comgunitfmodel_NoteFormat: scalaxb.XMLFormat[com.gu.nitf.model.Note] = new DefaultComgunitfmodel_NoteFormat {}
  implicit lazy val Comgunitfmodel_NoteSequence1Format: scalaxb.XMLFormat[com.gu.nitf.model.NoteSequence1] = new DefaultComgunitfmodel_NoteSequence1Format {}
  implicit lazy val Comgunitfmodel_RightsFormat: scalaxb.XMLFormat[com.gu.nitf.model.Rights] = new DefaultComgunitfmodel_RightsFormat {}
  implicit lazy val Comgunitfmodel_RightsOwnerFormat: scalaxb.XMLFormat[com.gu.nitf.model.RightsOwner] = new DefaultComgunitfmodel_RightsOwnerFormat {}
  implicit lazy val Comgunitfmodel_RightsStartdateFormat: scalaxb.XMLFormat[com.gu.nitf.model.RightsStartdate] = new DefaultComgunitfmodel_RightsStartdateFormat {}
  implicit lazy val Comgunitfmodel_RightsEnddateFormat: scalaxb.XMLFormat[com.gu.nitf.model.RightsEnddate] = new DefaultComgunitfmodel_RightsEnddateFormat {}
  implicit lazy val Comgunitfmodel_RightsAgentFormat: scalaxb.XMLFormat[com.gu.nitf.model.RightsAgent] = new DefaultComgunitfmodel_RightsAgentFormat {}
  implicit lazy val Comgunitfmodel_RightsGeographyFormat: scalaxb.XMLFormat[com.gu.nitf.model.RightsGeography] = new DefaultComgunitfmodel_RightsGeographyFormat {}
  implicit lazy val Comgunitfmodel_RightsTypeFormat: scalaxb.XMLFormat[com.gu.nitf.model.RightsType] = new DefaultComgunitfmodel_RightsTypeFormat {}
  implicit lazy val Comgunitfmodel_RightsLimitationsFormat: scalaxb.XMLFormat[com.gu.nitf.model.RightsLimitations] = new DefaultComgunitfmodel_RightsLimitationsFormat {}
  implicit lazy val Comgunitfmodel_BylineFormat: scalaxb.XMLFormat[com.gu.nitf.model.Byline] = new DefaultComgunitfmodel_BylineFormat {}
  implicit lazy val Comgunitfmodel_ByttlFormat: scalaxb.XMLFormat[com.gu.nitf.model.Byttl] = new DefaultComgunitfmodel_ByttlFormat {}
  implicit lazy val Comgunitfmodel_DistributorFormat: scalaxb.XMLFormat[com.gu.nitf.model.Distributor] = new DefaultComgunitfmodel_DistributorFormat {}
  implicit lazy val Comgunitfmodel_DatelineFormat: scalaxb.XMLFormat[com.gu.nitf.model.Dateline] = new DefaultComgunitfmodel_DatelineFormat {}
  implicit lazy val Comgunitfmodel_StoryDateFormat: scalaxb.XMLFormat[com.gu.nitf.model.StoryDate] = new DefaultComgunitfmodel_StoryDateFormat {}
  implicit lazy val Comgunitfmodel_AbstractFormat: scalaxb.XMLFormat[com.gu.nitf.model.Abstract] = new DefaultComgunitfmodel_AbstractFormat {}
  implicit lazy val Comgunitfmodel_CopyriteFormat: scalaxb.XMLFormat[com.gu.nitf.model.Copyrite] = new DefaultComgunitfmodel_CopyriteFormat {}
  implicit lazy val Comgunitfmodel_CopyriteYearFormat: scalaxb.XMLFormat[com.gu.nitf.model.CopyriteYear] = new DefaultComgunitfmodel_CopyriteYearFormat {}
  implicit lazy val Comgunitfmodel_CopyriteHolderFormat: scalaxb.XMLFormat[com.gu.nitf.model.CopyriteHolder] = new DefaultComgunitfmodel_CopyriteHolderFormat {}
  implicit lazy val Comgunitfmodel_BodyContentFormat: scalaxb.XMLFormat[com.gu.nitf.model.BodyContent] = new DefaultComgunitfmodel_BodyContentFormat {}
  implicit lazy val Comgunitfmodel_BlockFormat: scalaxb.XMLFormat[com.gu.nitf.model.Block] = new DefaultComgunitfmodel_BlockFormat {}
  implicit lazy val Comgunitfmodel_BlockSequence2Format: scalaxb.XMLFormat[com.gu.nitf.model.BlockSequence2] = new DefaultComgunitfmodel_BlockSequence2Format {}
  implicit lazy val Comgunitfmodel_BlockSequence1Format: scalaxb.XMLFormat[com.gu.nitf.model.BlockSequence1] = new DefaultComgunitfmodel_BlockSequence1Format {}
  implicit lazy val Comgunitfmodel_PFormat: scalaxb.XMLFormat[com.gu.nitf.model.P] = new DefaultComgunitfmodel_PFormat {}
  implicit lazy val Comgunitfmodel_AlignTypeFormat: scalaxb.XMLFormat[com.gu.nitf.model.AlignType] = new DefaultComgunitfmodel_AlignTypeFormat {}
  implicit lazy val Comgunitfmodel_FrameFormat: scalaxb.XMLFormat[com.gu.nitf.model.Frame] = new DefaultComgunitfmodel_FrameFormat {}
  implicit lazy val Comgunitfmodel_RulesFormat: scalaxb.XMLFormat[com.gu.nitf.model.Rules] = new DefaultComgunitfmodel_RulesFormat {}
  implicit lazy val Comgunitfmodel_TableFormat: scalaxb.XMLFormat[com.gu.nitf.model.Table] = new DefaultComgunitfmodel_TableFormat {}
  implicit lazy val Comgunitfmodel_MediaFormat: scalaxb.XMLFormat[com.gu.nitf.model.Media] = new DefaultComgunitfmodel_MediaFormat {}
  implicit lazy val Comgunitfmodel_MediaSequence1Format: scalaxb.XMLFormat[com.gu.nitf.model.MediaSequence1] = new DefaultComgunitfmodel_MediaSequence1Format {}
  implicit lazy val Comgunitfmodel_UnitsFormat: scalaxb.XMLFormat[com.gu.nitf.model.Units] = new DefaultComgunitfmodel_UnitsFormat {}
  implicit lazy val Comgunitfmodel_NoflowFormat: scalaxb.XMLFormat[com.gu.nitf.model.Noflow] = new DefaultComgunitfmodel_NoflowFormat {}
  implicit lazy val Comgunitfmodel_MediaReferenceFormat: scalaxb.XMLFormat[com.gu.nitf.model.MediaReference] = new DefaultComgunitfmodel_MediaReferenceFormat {}
  implicit lazy val Comgunitfmodel_MediaMetadataFormat: scalaxb.XMLFormat[com.gu.nitf.model.MediaMetadata] = new DefaultComgunitfmodel_MediaMetadataFormat {}
  implicit lazy val Comgunitfmodel_MediaObjectFormat: scalaxb.XMLFormat[com.gu.nitf.model.MediaObject] = new DefaultComgunitfmodel_MediaObjectFormat {}
  implicit lazy val Comgunitfmodel_MediaCaptionFormat: scalaxb.XMLFormat[com.gu.nitf.model.MediaCaption] = new DefaultComgunitfmodel_MediaCaptionFormat {}
  implicit lazy val Comgunitfmodel_MediaProducerFormat: scalaxb.XMLFormat[com.gu.nitf.model.MediaProducer] = new DefaultComgunitfmodel_MediaProducerFormat {}
  implicit lazy val Comgunitfmodel_OlFormat: scalaxb.XMLFormat[com.gu.nitf.model.Ol] = new DefaultComgunitfmodel_OlFormat {}
  implicit lazy val Comgunitfmodel_OlSequence1Format: scalaxb.XMLFormat[com.gu.nitf.model.OlSequence1] = new DefaultComgunitfmodel_OlSequence1Format {}
  implicit lazy val Comgunitfmodel_UlFormat: scalaxb.XMLFormat[com.gu.nitf.model.Ul] = new DefaultComgunitfmodel_UlFormat {}
  implicit lazy val Comgunitfmodel_UlSequence1Format: scalaxb.XMLFormat[com.gu.nitf.model.UlSequence1] = new DefaultComgunitfmodel_UlSequence1Format {}
  implicit lazy val Comgunitfmodel_LiFormat: scalaxb.XMLFormat[com.gu.nitf.model.Li] = new DefaultComgunitfmodel_LiFormat {}
  implicit lazy val Comgunitfmodel_DlFormat: scalaxb.XMLFormat[com.gu.nitf.model.Dl] = new DefaultComgunitfmodel_DlFormat {}
  implicit lazy val Comgunitfmodel_DtFormat: scalaxb.XMLFormat[com.gu.nitf.model.Dt] = new DefaultComgunitfmodel_DtFormat {}
  implicit lazy val Comgunitfmodel_DdFormat: scalaxb.XMLFormat[com.gu.nitf.model.Dd] = new DefaultComgunitfmodel_DdFormat {}
  implicit lazy val Comgunitfmodel_NowrapFormat: scalaxb.XMLFormat[com.gu.nitf.model.Nowrap] = new DefaultComgunitfmodel_NowrapFormat {}
  implicit lazy val Comgunitfmodel_BqFormat: scalaxb.XMLFormat[com.gu.nitf.model.Bq] = new DefaultComgunitfmodel_BqFormat {}
  implicit lazy val Comgunitfmodel_BqSequence1Format: scalaxb.XMLFormat[com.gu.nitf.model.BqSequence1] = new DefaultComgunitfmodel_BqSequence1Format {}
  implicit lazy val Comgunitfmodel_CreditFormat: scalaxb.XMLFormat[com.gu.nitf.model.Credit] = new DefaultComgunitfmodel_CreditFormat {}
  implicit lazy val Comgunitfmodel_FnFormat: scalaxb.XMLFormat[com.gu.nitf.model.Fn] = new DefaultComgunitfmodel_FnFormat {}
  implicit lazy val Comgunitfmodel_FnSequence1Format: scalaxb.XMLFormat[com.gu.nitf.model.FnSequence1] = new DefaultComgunitfmodel_FnSequence1Format {}
  implicit lazy val Comgunitfmodel_PreFormat: scalaxb.XMLFormat[com.gu.nitf.model.Pre] = new DefaultComgunitfmodel_PreFormat {}
  implicit lazy val Comgunitfmodel_HrFormat: scalaxb.XMLFormat[com.gu.nitf.model.Hr] = new DefaultComgunitfmodel_HrFormat {}
  implicit lazy val Comgunitfmodel_DatasourceFormat: scalaxb.XMLFormat[com.gu.nitf.model.Datasource] = new DefaultComgunitfmodel_DatasourceFormat {}
  implicit lazy val Comgunitfmodel_AlignType2Format: scalaxb.XMLFormat[com.gu.nitf.model.AlignType2] = new DefaultComgunitfmodel_AlignType2Format {}
  implicit lazy val Comgunitfmodel_CaptionFormat: scalaxb.XMLFormat[com.gu.nitf.model.Caption] = new DefaultComgunitfmodel_CaptionFormat {}
  implicit lazy val Comgunitfmodel_ColFormat: scalaxb.XMLFormat[com.gu.nitf.model.Col] = new DefaultComgunitfmodel_ColFormat {}
  implicit lazy val Comgunitfmodel_ColgroupFormat: scalaxb.XMLFormat[com.gu.nitf.model.Colgroup] = new DefaultComgunitfmodel_ColgroupFormat {}
  implicit lazy val Comgunitfmodel_TheadFormat: scalaxb.XMLFormat[com.gu.nitf.model.Thead] = new DefaultComgunitfmodel_TheadFormat {}
  implicit lazy val Comgunitfmodel_TbodyFormat: scalaxb.XMLFormat[com.gu.nitf.model.Tbody] = new DefaultComgunitfmodel_TbodyFormat {}
  implicit lazy val Comgunitfmodel_TfootFormat: scalaxb.XMLFormat[com.gu.nitf.model.Tfoot] = new DefaultComgunitfmodel_TfootFormat {}
  implicit lazy val Comgunitfmodel_TrFormat: scalaxb.XMLFormat[com.gu.nitf.model.Tr] = new DefaultComgunitfmodel_TrFormat {}
  implicit lazy val Comgunitfmodel_NowrapTypeFormat: scalaxb.XMLFormat[com.gu.nitf.model.NowrapType] = new DefaultComgunitfmodel_NowrapTypeFormat {}
  implicit lazy val Comgunitfmodel_ThFormat: scalaxb.XMLFormat[com.gu.nitf.model.Th] = new DefaultComgunitfmodel_ThFormat {}
  implicit lazy val Comgunitfmodel_NowrapType2Format: scalaxb.XMLFormat[com.gu.nitf.model.NowrapType2] = new DefaultComgunitfmodel_NowrapType2Format {}
  implicit lazy val Comgunitfmodel_TdFormat: scalaxb.XMLFormat[com.gu.nitf.model.Td] = new DefaultComgunitfmodel_TdFormat {}
  implicit lazy val Comgunitfmodel_ChronFormat: scalaxb.XMLFormat[com.gu.nitf.model.Chron] = new DefaultComgunitfmodel_ChronFormat {}
  implicit lazy val Comgunitfmodel_EventFormat: scalaxb.XMLFormat[com.gu.nitf.model.Event] = new DefaultComgunitfmodel_EventFormat {}
  implicit lazy val Comgunitfmodel_FunctionTypeFormat: scalaxb.XMLFormat[com.gu.nitf.model.FunctionType] = new DefaultComgunitfmodel_FunctionTypeFormat {}
  implicit lazy val Comgunitfmodel_LocationFormat: scalaxb.XMLFormat[com.gu.nitf.model.Location] = new DefaultComgunitfmodel_LocationFormat {}
  implicit lazy val Comgunitfmodel_SublocationFormat: scalaxb.XMLFormat[com.gu.nitf.model.Sublocation] = new DefaultComgunitfmodel_SublocationFormat {}
  implicit lazy val Comgunitfmodel_CityFormat: scalaxb.XMLFormat[com.gu.nitf.model.City] = new DefaultComgunitfmodel_CityFormat {}
  implicit lazy val Comgunitfmodel_StateFormat: scalaxb.XMLFormat[com.gu.nitf.model.State] = new DefaultComgunitfmodel_StateFormat {}
  implicit lazy val Comgunitfmodel_RegionFormat: scalaxb.XMLFormat[com.gu.nitf.model.Region] = new DefaultComgunitfmodel_RegionFormat {}
  implicit lazy val Comgunitfmodel_CountryFormat: scalaxb.XMLFormat[com.gu.nitf.model.Country] = new DefaultComgunitfmodel_CountryFormat {}
  implicit lazy val Comgunitfmodel_MoneyFormat: scalaxb.XMLFormat[com.gu.nitf.model.Money] = new DefaultComgunitfmodel_MoneyFormat {}
  implicit lazy val Comgunitfmodel_NumFormat: scalaxb.XMLFormat[com.gu.nitf.model.Num] = new DefaultComgunitfmodel_NumFormat {}
  implicit lazy val Comgunitfmodel_FracFormat: scalaxb.XMLFormat[com.gu.nitf.model.Frac] = new DefaultComgunitfmodel_FracFormat {}
  implicit lazy val Comgunitfmodel_NumerFormat: scalaxb.XMLFormat[com.gu.nitf.model.Numer] = new DefaultComgunitfmodel_NumerFormat {}
  implicit lazy val Comgunitfmodel_FracSepFormat: scalaxb.XMLFormat[com.gu.nitf.model.FracSep] = new DefaultComgunitfmodel_FracSepFormat {}
  implicit lazy val Comgunitfmodel_DenomFormat: scalaxb.XMLFormat[com.gu.nitf.model.Denom] = new DefaultComgunitfmodel_DenomFormat {}
  implicit lazy val Comgunitfmodel_SubFormat: scalaxb.XMLFormat[com.gu.nitf.model.Sub] = new DefaultComgunitfmodel_SubFormat {}
  implicit lazy val Comgunitfmodel_SupFormat: scalaxb.XMLFormat[com.gu.nitf.model.Sup] = new DefaultComgunitfmodel_SupFormat {}
  implicit lazy val Comgunitfmodel_ObjectTitleFormat: scalaxb.XMLFormat[com.gu.nitf.model.ObjectTitle] = new DefaultComgunitfmodel_ObjectTitleFormat {}
  implicit lazy val Comgunitfmodel_OrgFormat: scalaxb.XMLFormat[com.gu.nitf.model.Org] = new DefaultComgunitfmodel_OrgFormat {}
  implicit lazy val Comgunitfmodel_AltCodeFormat: scalaxb.XMLFormat[com.gu.nitf.model.AltCode] = new DefaultComgunitfmodel_AltCodeFormat {}
  implicit lazy val Comgunitfmodel_GenderFormat: scalaxb.XMLFormat[com.gu.nitf.model.Gender] = new DefaultComgunitfmodel_GenderFormat {}
  implicit lazy val Comgunitfmodel_PersonFormat: scalaxb.XMLFormat[com.gu.nitf.model.Person] = new DefaultComgunitfmodel_PersonFormat {}
  implicit lazy val Comgunitfmodel_NameGivenFormat: scalaxb.XMLFormat[com.gu.nitf.model.NameGiven] = new DefaultComgunitfmodel_NameGivenFormat {}
  implicit lazy val Comgunitfmodel_NameFamilyFormat: scalaxb.XMLFormat[com.gu.nitf.model.NameFamily] = new DefaultComgunitfmodel_NameFamilyFormat {}
  implicit lazy val Comgunitfmodel_PostaddrFormat: scalaxb.XMLFormat[com.gu.nitf.model.Postaddr] = new DefaultComgunitfmodel_PostaddrFormat {}
  implicit lazy val Comgunitfmodel_VirtlocFormat: scalaxb.XMLFormat[com.gu.nitf.model.Virtloc] = new DefaultComgunitfmodel_VirtlocFormat {}
  implicit lazy val Comgunitfmodel_AFormat: scalaxb.XMLFormat[com.gu.nitf.model.A] = new DefaultComgunitfmodel_AFormat {}
  implicit lazy val Comgunitfmodel_BrFormat: scalaxb.XMLFormat[com.gu.nitf.model.Br] = new DefaultComgunitfmodel_BrFormat {}
  implicit lazy val Comgunitfmodel_EmFormat: scalaxb.XMLFormat[com.gu.nitf.model.Em] = new DefaultComgunitfmodel_EmFormat {}
  implicit lazy val Comgunitfmodel_LangFormat: scalaxb.XMLFormat[com.gu.nitf.model.Lang] = new DefaultComgunitfmodel_LangFormat {}
  implicit lazy val Comgunitfmodel_PronounceFormat: scalaxb.XMLFormat[com.gu.nitf.model.Pronounce] = new DefaultComgunitfmodel_PronounceFormat {}
  implicit lazy val Comgunitfmodel_QFormat: scalaxb.XMLFormat[com.gu.nitf.model.Q] = new DefaultComgunitfmodel_QFormat {}
  implicit lazy val Comgunitfmodel_AddresseeFormat: scalaxb.XMLFormat[com.gu.nitf.model.Addressee] = new DefaultComgunitfmodel_AddresseeFormat {}
  implicit lazy val Comgunitfmodel_CareOfFormat: scalaxb.XMLFormat[com.gu.nitf.model.CareOf] = new DefaultComgunitfmodel_CareOfFormat {}
  implicit lazy val Comgunitfmodel_DeliveryPointFormat: scalaxb.XMLFormat[com.gu.nitf.model.DeliveryPoint] = new DefaultComgunitfmodel_DeliveryPointFormat {}
  implicit lazy val Comgunitfmodel_PostcodeFormat: scalaxb.XMLFormat[com.gu.nitf.model.Postcode] = new DefaultComgunitfmodel_PostcodeFormat {}
  implicit lazy val Comgunitfmodel_DeliveryOfficeFormat: scalaxb.XMLFormat[com.gu.nitf.model.DeliveryOffice] = new DefaultComgunitfmodel_DeliveryOfficeFormat {}
  implicit lazy val Comgunitfmodel_BodyEndFormat: scalaxb.XMLFormat[com.gu.nitf.model.BodyEnd] = new DefaultComgunitfmodel_BodyEndFormat {}
  implicit lazy val Comgunitfmodel_TypeType3Format: scalaxb.XMLFormat[com.gu.nitf.model.TypeType3] = new DefaultComgunitfmodel_TypeType3Format {}
  implicit lazy val Comgunitfmodel_TaglineFormat: scalaxb.XMLFormat[com.gu.nitf.model.Tagline] = new DefaultComgunitfmodel_TaglineFormat {}
  implicit lazy val Comgunitfmodel_BibliographyFormat: scalaxb.XMLFormat[com.gu.nitf.model.Bibliography] = new DefaultComgunitfmodel_BibliographyFormat {}
  implicit lazy val Comgunitfmodel_ClassifierFormat: scalaxb.XMLFormat[com.gu.nitf.model.Classifier] = new DefaultComgunitfmodel_ClassifierFormat {}
  implicit lazy val Comgunitfmodel_NitfTableFormat: scalaxb.XMLFormat[com.gu.nitf.model.NitfTable] = new DefaultComgunitfmodel_NitfTableFormat {}
  implicit lazy val Comgunitfmodel_CustomTableFormat: scalaxb.XMLFormat[com.gu.nitf.model.CustomTable] = new DefaultComgunitfmodel_CustomTableFormat {}
  implicit lazy val Comgunitfmodel_TableReferenceFormat: scalaxb.XMLFormat[com.gu.nitf.model.TableReference] = new DefaultComgunitfmodel_TableReferenceFormat {}
  implicit lazy val Comgunitfmodel_StatusFormat: scalaxb.XMLFormat[com.gu.nitf.model.Status] = new DefaultComgunitfmodel_StatusFormat {}
  implicit lazy val Comgunitfmodel_NitfTableMetadataFormat: scalaxb.XMLFormat[com.gu.nitf.model.NitfTableMetadata] = new DefaultComgunitfmodel_NitfTableMetadataFormat {}
  implicit lazy val Comgunitfmodel_NitfTableSummaryFormat: scalaxb.XMLFormat[com.gu.nitf.model.NitfTableSummary] = new DefaultComgunitfmodel_NitfTableSummaryFormat {}
  implicit lazy val Comgunitfmodel_NitfColgroupFormat: scalaxb.XMLFormat[com.gu.nitf.model.NitfColgroup] = new DefaultComgunitfmodel_NitfColgroupFormat {}
  implicit lazy val Comgunitfmodel_NitfColgroupSequence1Format: scalaxb.XMLFormat[com.gu.nitf.model.NitfColgroupSequence1] = new DefaultComgunitfmodel_NitfColgroupSequence1Format {}
  implicit lazy val Comgunitfmodel_DataTypeFormat: scalaxb.XMLFormat[com.gu.nitf.model.DataType] = new DefaultComgunitfmodel_DataTypeFormat {}
  implicit lazy val Comgunitfmodel_NitfColFormat: scalaxb.XMLFormat[com.gu.nitf.model.NitfCol] = new DefaultComgunitfmodel_NitfColFormat {}
  implicit lazy val Comgunitfmodel_CellVAlignFormat: scalaxb.AttributeGroupFormat[com.gu.nitf.model.CellVAlign] = new DefaultComgunitfmodel_CellVAlignFormat {}
  implicit lazy val Comgunitfmodel_CommonNITFAttributesFormat: scalaxb.AttributeGroupFormat[com.gu.nitf.model.CommonNITFAttributes] = new DefaultComgunitfmodel_CommonNITFAttributesFormat {}
  implicit lazy val Comgunitfmodel_GlobalNITFAttributesFormat: scalaxb.AttributeGroupFormat[com.gu.nitf.model.GlobalNITFAttributes] = new DefaultComgunitfmodel_GlobalNITFAttributesFormat {}
  implicit lazy val Comgunitfmodel_CellAlignFormat: scalaxb.AttributeGroupFormat[com.gu.nitf.model.CellAlign] = new DefaultComgunitfmodel_CellAlignFormat {}


  implicit val fromAnySchemaType: scala.xml.Elem => Option[scalaxb.DataRecord[Any]] = {elem =>
    import scalaxb.{Helper, DataRecord, fromXML}

    val ns = Helper.nullOrEmpty(elem.scope.getURI(elem.prefix))
    val key = Some(elem.label)
    val (xsns, xstype) = Helper.instanceType(elem)

    (key, ns) match {
      case (Some("nitf-col"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.NitfCol](elem)))
      case (Some("nitf-table-summary"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.NitfTableSummary](elem)))
      case (Some("table-reference"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.TableReference](elem)))
      case (Some("nitf-table"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.NitfTable](elem)))
      case (Some("bibliography"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Bibliography](elem)))
      case (Some("body.end"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.BodyEnd](elem)))
      case (Some("postcode"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Postcode](elem)))
      case (Some("care.of"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.CareOf](elem)))
      case (Some("q"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Q](elem)))
      case (Some("lang"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Lang](elem)))
      case (Some("br"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Br](elem)))
      case (Some("virtloc"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Virtloc](elem)))
      case (Some("name.family"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.NameFamily](elem)))
      case (Some("person"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Person](elem)))
      case (Some("org"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Org](elem)))
      case (Some("sup"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Sup](elem)))
      case (Some("denom"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Denom](elem)))
      case (Some("numer"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Numer](elem)))
      case (Some("num"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Num](elem)))
      case (Some("country"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Country](elem)))
      case (Some("state"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.State](elem)))
      case (Some("sublocation"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Sublocation](elem)))
      case (Some("function"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.FunctionType](elem)))
      case (Some("chron"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Chron](elem)))
      case (Some("th"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Th](elem)))
      case (Some("tfoot"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Tfoot](elem)))
      case (Some("thead"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Thead](elem)))
      case (Some("col"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Col](elem)))
      case (Some("datasource"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Datasource](elem)))
      case (Some("pre"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Pre](elem)))
      case (Some("credit"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Credit](elem)))
      case (Some("dd"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Dd](elem)))
      case (Some("dl"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Dl](elem)))
      case (Some("ul"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Ul](elem)))
      case (Some("media-producer"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.MediaProducer](elem)))
      case (Some("media-object"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.MediaObject](elem)))
      case (Some("media-reference"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.MediaReference](elem)))
      case (Some("table"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Table](elem)))
      case (Some("block"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Block](elem)))
      case (Some("copyrite.holder"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.CopyriteHolder](elem)))
      case (Some("copyrite"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Copyrite](elem)))
      case (Some("story.date"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.StoryDate](elem)))
      case (Some("distributor"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Distributor](elem)))
      case (Some("byline"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Byline](elem)))
      case (Some("rights.type"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.RightsType](elem)))
      case (Some("rights.agent"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.RightsAgent](elem)))
      case (Some("rights.startdate"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.RightsStartdate](elem)))
      case (Some("rights"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Rights](elem)))
      case (Some("hl2"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Hl2](elem)))
      case (Some("hedline"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Hedline](elem)))
      case (Some("body"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Body](elem)))
      case (Some("pubdata"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Pubdata](elem)))
      case (Some("keyword"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Keyword](elem)))
      case (Some("doc.rights"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.DocRights](elem)))
      case (Some("du-key"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.DuKey](elem)))
      case (Some("series"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Series](elem)))
      case (Some("date.expire"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.DateExpire](elem)))
      case (Some("date.issue"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.DateIssue](elem)))
      case (Some("urgency"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Urgency](elem)))
      case (Some("del-list"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.DelList](elem)))
      case (Some("evloc"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Evloc](elem)))
      case (Some("docdata"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Docdata](elem)))
      case (Some("iim"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Iim](elem)))
      case (Some("tobject.property"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.TobjectProperty](elem)))
      case (Some("meta"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Meta](elem)))
      case (Some("head"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Head](elem)))
      case (Some("nitf"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Nitf](elem)))
      case (Some("title"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Title](elem)))
      case (Some("tobject"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Tobject](elem)))
      case (Some("tobject.subject"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.TobjectSubject](elem)))
      case (Some("ds"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Ds](elem)))
      case (Some("correction"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Correction](elem)))
      case (Some("doc-id"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.DocId](elem)))
      case (Some("from-src"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.FromSrc](elem)))
      case (Some("fixture"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Fixture](elem)))
      case (Some("date.release"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.DateRelease](elem)))
      case (Some("doc-scope"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.DocScope](elem)))
      case (Some("ed-msg"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.EdMsg](elem)))
      case (Some("doc.copyright"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.DocCopyright](elem)))
      case (Some("key-list"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.KeyList](elem)))
      case (Some("identified-content"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.IdentifiedContent](elem)))
      case (Some("revision-history"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.RevisionHistory](elem)))
      case (Some("body.head"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.BodyHead](elem)))
      case (Some("hl1"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Hl1](elem)))
      case (Some("note"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Note](elem)))
      case (Some("rights.owner"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.RightsOwner](elem)))
      case (Some("rights.enddate"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.RightsEnddate](elem)))
      case (Some("rights.geography"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.RightsGeography](elem)))
      case (Some("rights.limitations"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.RightsLimitations](elem)))
      case (Some("byttl"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Byttl](elem)))
      case (Some("dateline"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Dateline](elem)))
      case (Some("abstract"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Abstract](elem)))
      case (Some("copyrite.year"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.CopyriteYear](elem)))
      case (Some("body.content"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.BodyContent](elem)))
      case (Some("p"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.P](elem)))
      case (Some("media"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Media](elem)))
      case (Some("media-metadata"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.MediaMetadata](elem)))
      case (Some("media-caption"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.MediaCaption](elem)))
      case (Some("ol"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Ol](elem)))
      case (Some("li"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Li](elem)))
      case (Some("dt"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Dt](elem)))
      case (Some("bq"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Bq](elem)))
      case (Some("fn"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Fn](elem)))
      case (Some("hr"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Hr](elem)))
      case (Some("caption"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Caption](elem)))
      case (Some("colgroup"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Colgroup](elem)))
      case (Some("tbody"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Tbody](elem)))
      case (Some("tr"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Tr](elem)))
      case (Some("td"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Td](elem)))
      case (Some("event"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Event](elem)))
      case (Some("location"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Location](elem)))
      case (Some("city"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.City](elem)))
      case (Some("region"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Region](elem)))
      case (Some("money"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Money](elem)))
      case (Some("frac"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Frac](elem)))
      case (Some("frac-sep"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.FracSep](elem)))
      case (Some("sub"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Sub](elem)))
      case (Some("object.title"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.ObjectTitle](elem)))
      case (Some("alt-code"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.AltCode](elem)))
      case (Some("name.given"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.NameGiven](elem)))
      case (Some("postaddr"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Postaddr](elem)))
      case (Some("a"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.A](elem)))
      case (Some("em"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Em](elem)))
      case (Some("pronounce"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Pronounce](elem)))
      case (Some("addressee"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Addressee](elem)))
      case (Some("delivery.point"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.DeliveryPoint](elem)))
      case (Some("delivery.office"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.DeliveryOffice](elem)))
      case (Some("tagline"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Tagline](elem)))
      case (Some("classifier"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.Classifier](elem)))
      case (Some("custom-table"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.CustomTable](elem)))
      case (Some("nitf-table-metadata"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.NitfTableMetadata](elem)))
      case (Some("nitf-colgroup"), Some("http://iptc.org/std/nitf/2006-03-01/") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[com.gu.nitf.model.NitfColgroup](elem)))

      case _ => None
    }


  }

  def buildComgunitfmodel_AlignFormat = new DefaultComgunitfmodel_AlignFormat {}
  trait DefaultComgunitfmodel_AlignFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Align] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("align")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.Align = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("left")) => com.gu.nitf.model.LeftType
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("center")) => com.gu.nitf.model.Center
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("right")) => com.gu.nitf.model.RightType
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("justify")) => com.gu.nitf.model.Justify
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("char")) => com.gu.nitf.model.CharType

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Align] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.Align, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildComgunitfmodel_ValignFormat = new DefaultComgunitfmodel_ValignFormat {}
  trait DefaultComgunitfmodel_ValignFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Valign] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("valign")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.Valign = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("top")) => com.gu.nitf.model.Top
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("middle")) => com.gu.nitf.model.Middle
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bottom")) => com.gu.nitf.model.Bottom
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("baseline")) => com.gu.nitf.model.Baseline

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Valign] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.Valign, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultComgunitfmodel_NitfFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Nitf] {
    override val defaultElementLabel: Option[String] = Some("nitf")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Nitf] =
      phrase(opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "head")) ~ 
      (scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "body")) ^^
      { case p1 ~ p2 =>
      com.gu.nitf.model.Nitf(p1.headOption map { scalaxb.fromXML[com.gu.nitf.model.Head](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[com.gu.nitf.model.Body](p2, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@uno").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@uno" -> _ },
        Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("-//IPTC//DTD NITF 3.3//EN"), scalaxb.ElemName(node) :: stack))) map { "@version" -> _ },
        Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("March 4, 2005"), scalaxb.ElemName(node) :: stack))) map { "@change.date" -> _ },
        Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("19:30"), scalaxb.ElemName(node) :: stack))) map { "@change.time" -> _ },
        (node \ "@baselang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@baselang" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Seq[String]](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Nitf, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@uno", _) => __obj.uno foreach { x => attr = scala.xml.Attribute(null, "uno", x.toString, attr) }
        case ("@version", _) => attr = scala.xml.Attribute(null, "version", __obj.version.toString, attr)
        case ("@change.date", _) => attr = scala.xml.Attribute(null, "change.date", __obj.changeDate.toString, attr)
        case ("@change.time", _) => attr = scala.xml.Attribute(null, "change.time", __obj.changeTime.toString, attr)
        case ("@baselang", _) => __obj.baselang foreach { x => attr = scala.xml.Attribute(null, "baselang", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Nitf, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.head map { scalaxb.toXML[com.gu.nitf.model.Head](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("head"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[com.gu.nitf.model.Body](__obj.body, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("body"), __scope, false))

  }

  trait DefaultComgunitfmodel_HeadFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Head] {
    override val defaultElementLabel: Option[String] = Some("head")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Head] =
      phrase(opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "title")) ~ 
      safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "meta")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "tobject")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "iim")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "docdata")) ~ 
      safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "pubdata")) ~ 
      safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "revision-history")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      com.gu.nitf.model.Head(p1.headOption map { scalaxb.fromXML[com.gu.nitf.model.Title](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[com.gu.nitf.model.Meta](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[com.gu.nitf.model.Tobject](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.gu.nitf.model.Iim](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[com.gu.nitf.model.Docdata](_, scalaxb.ElemName(node) :: stack) },
        p6 map { scalaxb.fromXML[com.gu.nitf.model.Pubdata](_, scalaxb.ElemName(node) :: stack) },
        p7 map { scalaxb.fromXML[com.gu.nitf.model.RevisionHistory](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Head, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Head, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.title map { scalaxb.toXML[com.gu.nitf.model.Title](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("title"), __scope, false) } getOrElse {Nil},
        __obj.meta flatMap { scalaxb.toXML[com.gu.nitf.model.Meta](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("meta"), __scope, false) },
        __obj.tobject map { scalaxb.toXML[com.gu.nitf.model.Tobject](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("tobject"), __scope, false) } getOrElse {Nil},
        __obj.iim map { scalaxb.toXML[com.gu.nitf.model.Iim](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("iim"), __scope, false) } getOrElse {Nil},
        __obj.docdata map { scalaxb.toXML[com.gu.nitf.model.Docdata](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("docdata"), __scope, false) } getOrElse {Nil},
        __obj.pubdata flatMap { scalaxb.toXML[com.gu.nitf.model.Pubdata](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("pubdata"), __scope, false) },
        __obj.revisionHistory flatMap { scalaxb.toXML[com.gu.nitf.model.RevisionHistory](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("revision-history"), __scope, false) })

  }

  def buildComgunitfmodel_TypeFormat = new DefaultComgunitfmodel_TypeFormat {}
  trait DefaultComgunitfmodel_TypeFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Type] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("type")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.Type = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("main")) => com.gu.nitf.model.Main
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("subtitle")) => com.gu.nitf.model.Subtitle
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("parttitle")) => com.gu.nitf.model.Parttitle
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("alternate")) => com.gu.nitf.model.Alternate
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("abbrev")) => com.gu.nitf.model.Abbrev
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("other")) => com.gu.nitf.model.Other

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Type] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.Type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultComgunitfmodel_TitleFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Title] {
    override val defaultElementLabel: Option[String] = Some("title")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Title] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.Title(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Type](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Title, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@type", _) => __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Title, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_MetaFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Meta] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.Meta] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("meta")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Meta] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.Meta(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@http-equiv").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@http-equiv" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@content").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@content" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.Meta, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@http-equiv", _) => __obj.httpEquiv foreach { x => attr = scala.xml.Attribute(null, "http-equiv", x.toString, attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@content", _) => attr = scala.xml.Attribute(null, "content", __obj.content.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Meta, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_TobjectFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Tobject] {
    override val defaultElementLabel: Option[String] = Some("tobject")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Tobject] =
      phrase(safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "tobject.property")) ~ 
      safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "tobject.subject")) ^^
      { case p1 ~ p2 =>
      com.gu.nitf.model.Tobject(p1 map { scalaxb.fromXML[com.gu.nitf.model.TobjectProperty](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[com.gu.nitf.model.TobjectSubject](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@tobject.type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("news"), scalaxb.ElemName(node) :: stack))) map { "@tobject.type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Tobject, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@tobject.type", _) => if (__obj.tobjectType.toString != "news") attr = scala.xml.Attribute(null, "tobject.type", __obj.tobjectType.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Tobject, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.tobjectProperty flatMap { scalaxb.toXML[com.gu.nitf.model.TobjectProperty](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("tobject.property"), __scope, false) },
        __obj.tobjectSubject flatMap { scalaxb.toXML[com.gu.nitf.model.TobjectSubject](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("tobject.subject"), __scope, false) })

  }

  trait DefaultComgunitfmodel_TobjectPropertyFormat extends scalaxb.XMLFormat[com.gu.nitf.model.TobjectProperty] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.TobjectProperty] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("tobject.property")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.TobjectProperty] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.TobjectProperty(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@tobject.property.type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("current"), scalaxb.ElemName(node) :: stack))) map { "@tobject.property.type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.TobjectProperty, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@tobject.property.type", _) => if (__obj.tobjectPropertyType.toString != "current") attr = scala.xml.Attribute(null, "tobject.property.type", __obj.tobjectPropertyType.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.TobjectProperty, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_TobjectSubjectFormat extends scalaxb.XMLFormat[com.gu.nitf.model.TobjectSubject] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.TobjectSubject] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("tobject.subject")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.TobjectSubject] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.TobjectSubject(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@tobject.subject.ipr").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("IPTC"), scalaxb.ElemName(node) :: stack))) map { "@tobject.subject.ipr" -> _ },
        (node \ "@tobject.subject.refnum").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@tobject.subject.refnum" -> _ },
        (node \ "@tobject.subject.code").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@tobject.subject.code" -> _ },
        (node \ "@tobject.subject.type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@tobject.subject.type" -> _ },
        (node \ "@tobject.subject.matter").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@tobject.subject.matter" -> _ },
        (node \ "@tobject.subject.detail").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@tobject.subject.detail" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.TobjectSubject, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@tobject.subject.ipr", _) => if (__obj.tobjectSubjectIpr.toString != "IPTC") attr = scala.xml.Attribute(null, "tobject.subject.ipr", __obj.tobjectSubjectIpr.toString, attr)
        case ("@tobject.subject.refnum", _) => attr = scala.xml.Attribute(null, "tobject.subject.refnum", __obj.tobjectSubjectRefnum.toString, attr)
        case ("@tobject.subject.code", _) => __obj.tobjectSubjectCode foreach { x => attr = scala.xml.Attribute(null, "tobject.subject.code", x.toString, attr) }
        case ("@tobject.subject.type", _) => __obj.tobjectSubjectType foreach { x => attr = scala.xml.Attribute(null, "tobject.subject.type", x.toString, attr) }
        case ("@tobject.subject.matter", _) => __obj.tobjectSubjectMatter foreach { x => attr = scala.xml.Attribute(null, "tobject.subject.matter", x.toString, attr) }
        case ("@tobject.subject.detail", _) => __obj.tobjectSubjectDetail foreach { x => attr = scala.xml.Attribute(null, "tobject.subject.detail", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.TobjectSubject, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_IimFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Iim] {
    override val defaultElementLabel: Option[String] = Some("iim")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Iim] =
      phrase(safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "ds")) ^^
      { case p1 =>
      com.gu.nitf.model.Iim(p1 map { scalaxb.fromXML[com.gu.nitf.model.Ds](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@ver").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@ver" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Iim, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@ver", _) => __obj.ver foreach { x => attr = scala.xml.Attribute(null, "ver", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Iim, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.ds flatMap { scalaxb.toXML[com.gu.nitf.model.Ds](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("ds"), __scope, false) })

  }

  trait DefaultComgunitfmodel_DsFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Ds] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.Ds] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("ds")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Ds] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.Ds(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@num").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@num" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.Ds, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@num", _) => attr = scala.xml.Attribute(null, "num", __obj.num.toString, attr)
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Ds, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_DocdataFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Docdata] {
    override val defaultElementLabel: Option[String] = Some("docdata")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Docdata] =
      phrase(safeRep(((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "correction")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Correction](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "evloc")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Evloc](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "doc-id")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.DocId](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "del-list")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.DelList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "urgency")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Urgency](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "fixture")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Fixture](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "date.issue")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.DateIssue](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "date.release")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.DateRelease](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "date.expire")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.DateExpire](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "doc-scope")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.DocScope](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "series")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Series](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "ed-msg")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.EdMsg](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "du-key")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.DuKey](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "doc.copyright")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.DocCopyright](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "doc.rights")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.DocRights](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "key-list")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.KeyList](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "identified-content")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.IdentifiedContent](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      com.gu.nitf.model.Docdata(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@management-status").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@management-status" -> _ },
        (node \ "@management-doc-idref").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@management-doc-idref" -> _ },
        (node \ "@management-idref-status").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@management-idref-status" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Docdata, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@management-status", _) => __obj.managementStatus foreach { x => attr = scala.xml.Attribute(null, "management-status", x.toString, attr) }
        case ("@management-doc-idref", _) => __obj.managementDocIdref foreach { x => attr = scala.xml.Attribute(null, "management-doc-idref", x.toString, attr) }
        case ("@management-idref-status", _) => __obj.managementIdrefStatus foreach { x => attr = scala.xml.Attribute(null, "management-idref-status", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Docdata, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.docdataoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[com.gu.nitf.model.DocdataOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultComgunitfmodel_CorrectionFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Correction] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.Correction] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("correction")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Correction] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.Correction(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@info").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@info" -> _ },
        (node \ "@id-string").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id-string" -> _ },
        (node \ "@regsrc").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@regsrc" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.Correction, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@info", _) => __obj.info foreach { x => attr = scala.xml.Attribute(null, "info", x.toString, attr) }
        case ("@id-string", _) => __obj.idString foreach { x => attr = scala.xml.Attribute(null, "id-string", x.toString, attr) }
        case ("@regsrc", _) => __obj.regsrc foreach { x => attr = scala.xml.Attribute(null, "regsrc", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Correction, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_EvlocFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Evloc] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.Evloc] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("evloc")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Evloc] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.Evloc(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@iso-cc").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@iso-cc" -> _ },
        (node \ "@state-prov").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@state-prov" -> _ },
        (node \ "@county-dist").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@county-dist" -> _ },
        (node \ "@city").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@city" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.Evloc, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@iso-cc", _) => __obj.isoCc foreach { x => attr = scala.xml.Attribute(null, "iso-cc", x.toString, attr) }
        case ("@state-prov", _) => __obj.stateProv foreach { x => attr = scala.xml.Attribute(null, "state-prov", x.toString, attr) }
        case ("@county-dist", _) => __obj.countyDist foreach { x => attr = scala.xml.Attribute(null, "county-dist", x.toString, attr) }
        case ("@city", _) => __obj.city foreach { x => attr = scala.xml.Attribute(null, "city", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Evloc, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_DocIdFormat extends scalaxb.XMLFormat[com.gu.nitf.model.DocId] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.DocId] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("doc-id")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.DocId] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.DocId(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@regsrc").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@regsrc" -> _ },
        (node \ "@id-string").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id-string" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.DocId, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@regsrc", _) => __obj.regsrc foreach { x => attr = scala.xml.Attribute(null, "regsrc", x.toString, attr) }
        case ("@id-string", _) => __obj.idString foreach { x => attr = scala.xml.Attribute(null, "id-string", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.DocId, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_DelListFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.DelList] {
    override val defaultElementLabel: Option[String] = Some("del-list")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.DelList] =
      phrase(safeRep(((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "from-src"))) ^^ 
        { case p1 => com.gu.nitf.model.DelListSequence1(scalaxb.fromXML[com.gu.nitf.model.FromSrc](p1, scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      com.gu.nitf.model.DelList(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.DelList, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.DelList, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.dellistsequence1 flatMap { scalaxb.toXML[com.gu.nitf.model.DelListSequence1](_, None, Some("dellistsequence1"), __scope, false) })

  }

  trait DefaultComgunitfmodel_DelListSequence1Format extends scalaxb.XMLFormat[com.gu.nitf.model.DelListSequence1] {
    final override def defaultElementLabel: Option[String] = None  // sequences have no label
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.DelListSequence1] = Left("don't call me.")
    
    def writes(__obj: com.gu.nitf.model.DelListSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[com.gu.nitf.model.FromSrc](__obj.fromSrc, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("from-src"), __scope, false)


  }

  trait DefaultComgunitfmodel_FromSrcFormat extends scalaxb.XMLFormat[com.gu.nitf.model.FromSrc] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.FromSrc] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("from-src")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.FromSrc] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.FromSrc(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@src-name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@src-name" -> _ },
        (node \ "@level-number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@level-number" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.FromSrc, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@src-name", _) => __obj.srcName foreach { x => attr = scala.xml.Attribute(null, "src-name", x.toString, attr) }
        case ("@level-number", _) => __obj.levelNumber foreach { x => attr = scala.xml.Attribute(null, "level-number", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.FromSrc, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_UrgencyFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Urgency] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.Urgency] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("urgency")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Urgency] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.Urgency(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@ed-urg").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@ed-urg" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.Urgency, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@ed-urg", _) => __obj.edUrg foreach { x => attr = scala.xml.Attribute(null, "ed-urg", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Urgency, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_FixtureFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Fixture] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.Fixture] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("fixture")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Fixture] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.Fixture(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@fix-id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@fix-id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.Fixture, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@fix-id", _) => __obj.fixId foreach { x => attr = scala.xml.Attribute(null, "fix-id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Fixture, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_DateIssueFormat extends scalaxb.XMLFormat[com.gu.nitf.model.DateIssue] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.DateIssue] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("date.issue")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.DateIssue] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.DateIssue(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@norm").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@norm" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.DateIssue, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@norm", _) => __obj.norm foreach { x => attr = scala.xml.Attribute(null, "norm", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.DateIssue, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_DateReleaseFormat extends scalaxb.XMLFormat[com.gu.nitf.model.DateRelease] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.DateRelease] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("date.release")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.DateRelease] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.DateRelease(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@norm").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@norm" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.DateRelease, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@norm", _) => __obj.norm foreach { x => attr = scala.xml.Attribute(null, "norm", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.DateRelease, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_DateExpireFormat extends scalaxb.XMLFormat[com.gu.nitf.model.DateExpire] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.DateExpire] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("date.expire")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.DateExpire] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.DateExpire(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@norm").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@norm" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.DateExpire, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@norm", _) => __obj.norm foreach { x => attr = scala.xml.Attribute(null, "norm", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.DateExpire, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_DocScopeFormat extends scalaxb.XMLFormat[com.gu.nitf.model.DocScope] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.DocScope] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("doc-scope")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.DocScope] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.DocScope(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@scope").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@scope" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.DocScope, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@scope", _) => __obj.scope foreach { x => attr = scala.xml.Attribute(null, "scope", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.DocScope, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_SeriesFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Series] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.Series] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("series")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Series] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.Series(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@series.name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@series.name" -> _ },
        (node \ "@series.part").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack))) map { "@series.part" -> _ },
        (node \ "@series.totalpart").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack))) map { "@series.totalpart" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.Series, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@series.name", _) => __obj.seriesName foreach { x => attr = scala.xml.Attribute(null, "series.name", x.toString, attr) }
        case ("@series.part", _) => if (__obj.seriesPart.toString != "0") attr = scala.xml.Attribute(null, "series.part", __obj.seriesPart.toString, attr)
        case ("@series.totalpart", _) => if (__obj.seriesTotalpart.toString != "0") attr = scala.xml.Attribute(null, "series.totalpart", __obj.seriesTotalpart.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Series, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_EdMsgFormat extends scalaxb.XMLFormat[com.gu.nitf.model.EdMsg] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.EdMsg] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("ed-msg")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.EdMsg] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.EdMsg(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@msg-type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@msg-type" -> _ },
        (node \ "@info").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@info" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.EdMsg, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@msg-type", _) => __obj.msgType foreach { x => attr = scala.xml.Attribute(null, "msg-type", x.toString, attr) }
        case ("@info", _) => __obj.info foreach { x => attr = scala.xml.Attribute(null, "info", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.EdMsg, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_DuKeyFormat extends scalaxb.XMLFormat[com.gu.nitf.model.DuKey] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.DuKey] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("du-key")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.DuKey] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.DuKey(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@generation").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@generation" -> _ },
        (node \ "@part").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@part" -> _ },
        (node \ "@version").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@version" -> _ },
        (node \ "@key").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@key" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.DuKey, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@generation", _) => __obj.generation foreach { x => attr = scala.xml.Attribute(null, "generation", x.toString, attr) }
        case ("@part", _) => __obj.part foreach { x => attr = scala.xml.Attribute(null, "part", x.toString, attr) }
        case ("@version", _) => __obj.version foreach { x => attr = scala.xml.Attribute(null, "version", x.toString, attr) }
        case ("@key", _) => __obj.key foreach { x => attr = scala.xml.Attribute(null, "key", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.DuKey, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_DocCopyrightFormat extends scalaxb.XMLFormat[com.gu.nitf.model.DocCopyright] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.DocCopyright] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("doc.copyright")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.DocCopyright] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.DocCopyright(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@year").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@year" -> _ },
        (node \ "@holder").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@holder" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.DocCopyright, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@year", _) => __obj.year foreach { x => attr = scala.xml.Attribute(null, "year", x.toString, attr) }
        case ("@holder", _) => __obj.holder foreach { x => attr = scala.xml.Attribute(null, "holder", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.DocCopyright, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_DocRightsFormat extends scalaxb.XMLFormat[com.gu.nitf.model.DocRights] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.DocRights] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("doc.rights")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.DocRights] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.DocRights(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@owner").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@owner" -> _ },
        (node \ "@startdate").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@startdate" -> _ },
        (node \ "@enddate").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@enddate" -> _ },
        (node \ "@agent").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@agent" -> _ },
        (node \ "@geography").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@geography" -> _ },
        (node \ "@location-code").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@location-code" -> _ },
        (node \ "@code-source").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@code-source" -> _ },
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@limitations").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@limitations" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.DocRights, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@owner", _) => __obj.owner foreach { x => attr = scala.xml.Attribute(null, "owner", x.toString, attr) }
        case ("@startdate", _) => __obj.startdate foreach { x => attr = scala.xml.Attribute(null, "startdate", x.toString, attr) }
        case ("@enddate", _) => __obj.enddate foreach { x => attr = scala.xml.Attribute(null, "enddate", x.toString, attr) }
        case ("@agent", _) => __obj.agent foreach { x => attr = scala.xml.Attribute(null, "agent", x.toString, attr) }
        case ("@geography", _) => __obj.geography foreach { x => attr = scala.xml.Attribute(null, "geography", x.toString, attr) }
        case ("@location-code", _) => __obj.locationCode foreach { x => attr = scala.xml.Attribute(null, "location-code", x.toString, attr) }
        case ("@code-source", _) => __obj.codeSource foreach { x => attr = scala.xml.Attribute(null, "code-source", x.toString, attr) }
        case ("@type", _) => __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
        case ("@limitations", _) => __obj.limitations foreach { x => attr = scala.xml.Attribute(null, "limitations", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.DocRights, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_KeyListFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.KeyList] {
    override val defaultElementLabel: Option[String] = Some("key-list")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.KeyList] =
      phrase(safeRep(((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "keyword"))) ^^ 
        { case p1 => com.gu.nitf.model.KeyListSequence1(scalaxb.fromXML[com.gu.nitf.model.Keyword](p1, scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      com.gu.nitf.model.KeyList(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.KeyList, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.KeyList, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.keylistsequence1 flatMap { scalaxb.toXML[com.gu.nitf.model.KeyListSequence1](_, None, Some("keylistsequence1"), __scope, false) })

  }

  trait DefaultComgunitfmodel_KeyListSequence1Format extends scalaxb.XMLFormat[com.gu.nitf.model.KeyListSequence1] {
    final override def defaultElementLabel: Option[String] = None  // sequences have no label
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.KeyListSequence1] = Left("don't call me.")
    
    def writes(__obj: com.gu.nitf.model.KeyListSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[com.gu.nitf.model.Keyword](__obj.keyword, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("keyword"), __scope, false)


  }

  trait DefaultComgunitfmodel_KeywordFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Keyword] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.Keyword] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("keyword")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Keyword] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.Keyword(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@key").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@key" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.Keyword, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@key", _) => __obj.key foreach { x => attr = scala.xml.Attribute(null, "key", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Keyword, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_IdentifiedContentFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.IdentifiedContent] {
    override val defaultElementLabel: Option[String] = Some("identified-content")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.IdentifiedContent] =
      phrase(safeRep(((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "person")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Person](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "org")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Org](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "location")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Location](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "event")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Event](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "function")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.FunctionType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "object.title")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.ObjectTitle](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "virtloc")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Virtloc](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "classifier")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Classifier](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      com.gu.nitf.model.IdentifiedContent(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.IdentifiedContent, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.IdentifiedContent, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.identifiedcontentoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[com.gu.nitf.model.IdentifiedContentOption]](x, x.namespace, x.key, __scope, false) })

  }

  def buildComgunitfmodel_TypeTypeFormat = new DefaultComgunitfmodel_TypeTypeFormat {}
  trait DefaultComgunitfmodel_TypeTypeFormat extends scalaxb.XMLFormat[com.gu.nitf.model.TypeType] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("type")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.TypeType = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("print")) => com.gu.nitf.model.Print
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("audio")) => com.gu.nitf.model.Audio
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("video")) => com.gu.nitf.model.Video
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("web")) => com.gu.nitf.model.Web
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("appliance")) => com.gu.nitf.model.Appliance
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("other")) => com.gu.nitf.model.OtherValue

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.TypeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.TypeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultComgunitfmodel_PubdataFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Pubdata] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.Pubdata] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("pubdata")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Pubdata] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.Pubdata(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.TypeType](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@item-length").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@item-length" -> _ },
        (node \ "@unit-of-measure").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@unit-of-measure" -> _ },
        (node \ "@date.publication").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@date.publication" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@issn").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@issn" -> _ },
        (node \ "@volume").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@volume" -> _ },
        (node \ "@number").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@number" -> _ },
        (node \ "@issue").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@issue" -> _ },
        (node \ "@edition.name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@edition.name" -> _ },
        (node \ "@edition.area").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@edition.area" -> _ },
        (node \ "@position.section").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@position.section" -> _ },
        (node \ "@position.sequence").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@position.sequence" -> _ },
        (node \ "@ex-ref").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@ex-ref" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.Pubdata, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@type", _) => __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
        case ("@item-length", _) => __obj.itemLength foreach { x => attr = scala.xml.Attribute(null, "item-length", x.toString, attr) }
        case ("@unit-of-measure", _) => __obj.unitOfMeasure foreach { x => attr = scala.xml.Attribute(null, "unit-of-measure", x.toString, attr) }
        case ("@date.publication", _) => __obj.datePublication foreach { x => attr = scala.xml.Attribute(null, "date.publication", x.toString, attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@issn", _) => __obj.issn foreach { x => attr = scala.xml.Attribute(null, "issn", x.toString, attr) }
        case ("@volume", _) => __obj.volume foreach { x => attr = scala.xml.Attribute(null, "volume", x.toString, attr) }
        case ("@number", _) => __obj.number foreach { x => attr = scala.xml.Attribute(null, "number", x.toString, attr) }
        case ("@issue", _) => __obj.issue foreach { x => attr = scala.xml.Attribute(null, "issue", x.toString, attr) }
        case ("@edition.name", _) => __obj.editionName foreach { x => attr = scala.xml.Attribute(null, "edition.name", x.toString, attr) }
        case ("@edition.area", _) => __obj.editionArea foreach { x => attr = scala.xml.Attribute(null, "edition.area", x.toString, attr) }
        case ("@position.section", _) => __obj.positionSection foreach { x => attr = scala.xml.Attribute(null, "position.section", x.toString, attr) }
        case ("@position.sequence", _) => __obj.positionSequence foreach { x => attr = scala.xml.Attribute(null, "position.sequence", x.toString, attr) }
        case ("@ex-ref", _) => __obj.exRef foreach { x => attr = scala.xml.Attribute(null, "ex-ref", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Pubdata, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  def buildComgunitfmodel_FunctionTypeTypeFormat = new DefaultComgunitfmodel_FunctionTypeTypeFormat {}
  trait DefaultComgunitfmodel_FunctionTypeTypeFormat extends scalaxb.XMLFormat[com.gu.nitf.model.FunctionTypeType] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("function")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.FunctionTypeType = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("writer-author")) => com.gu.nitf.model.WriterAuthor
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("editor")) => com.gu.nitf.model.Editor
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("producer")) => com.gu.nitf.model.Producer
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("archivist")) => com.gu.nitf.model.Archivist
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("videographer")) => com.gu.nitf.model.Videographer
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("graphic-artist")) => com.gu.nitf.model.GraphicArtist
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("photographer")) => com.gu.nitf.model.Photographer
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("statistician")) => com.gu.nitf.model.Statistician
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("other")) => com.gu.nitf.model.OtherValue2

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.FunctionTypeType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.FunctionTypeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultComgunitfmodel_RevisionHistoryFormat extends scalaxb.XMLFormat[com.gu.nitf.model.RevisionHistory] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.RevisionHistory] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("revision-history")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.RevisionHistory] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.RevisionHistory(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@function").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.FunctionTypeType](x, scalaxb.ElemName(node) :: stack)) } map { "@function" -> _ },
        (node \ "@norm").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@norm" -> _ },
        (node \ "@comment").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@comment" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.RevisionHistory, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@function", _) => __obj.function foreach { x => attr = scala.xml.Attribute(null, "function", x.toString, attr) }
        case ("@norm", _) => __obj.norm foreach { x => attr = scala.xml.Attribute(null, "norm", x.toString, attr) }
        case ("@comment", _) => __obj.comment foreach { x => attr = scala.xml.Attribute(null, "comment", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.RevisionHistory, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_BodyFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Body] {
    override val defaultElementLabel: Option[String] = Some("body")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Body] =
      phrase(opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "body.head")) ~ 
      safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "body.content")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "body.end")) ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Body(p1.headOption map { scalaxb.fromXML[com.gu.nitf.model.BodyHead](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[com.gu.nitf.model.BodyContent](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[com.gu.nitf.model.BodyEnd](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Body, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Body, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.bodyHead map { scalaxb.toXML[com.gu.nitf.model.BodyHead](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("body.head"), __scope, false) } getOrElse {Nil},
        __obj.bodyContent flatMap { scalaxb.toXML[com.gu.nitf.model.BodyContent](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("body.content"), __scope, false) },
        __obj.bodyEnd map { scalaxb.toXML[com.gu.nitf.model.BodyEnd](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("body.end"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultComgunitfmodel_BodyHeadFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.BodyHead] {
    override val defaultElementLabel: Option[String] = Some("body.head")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.BodyHead] =
      phrase(safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "hedline")) ~ 
      safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "note")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "rights")) ~ 
      safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "byline")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "distributor")) ~ 
      safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "dateline")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "abstract")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "series")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 =>
      com.gu.nitf.model.BodyHead(p1 map { scalaxb.fromXML[com.gu.nitf.model.Hedline](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[com.gu.nitf.model.Note](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[com.gu.nitf.model.Rights](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[com.gu.nitf.model.Byline](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[com.gu.nitf.model.Distributor](_, scalaxb.ElemName(node) :: stack) },
        p6 map { scalaxb.fromXML[com.gu.nitf.model.Dateline](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[com.gu.nitf.model.Abstract](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[com.gu.nitf.model.Series](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.BodyHead, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.BodyHead, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.hedline flatMap { scalaxb.toXML[com.gu.nitf.model.Hedline](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("hedline"), __scope, false) },
        __obj.note flatMap { scalaxb.toXML[com.gu.nitf.model.Note](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("note"), __scope, false) },
        __obj.rights map { scalaxb.toXML[com.gu.nitf.model.Rights](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("rights"), __scope, false) } getOrElse {Nil},
        __obj.byline flatMap { scalaxb.toXML[com.gu.nitf.model.Byline](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("byline"), __scope, false) },
        __obj.distributor map { scalaxb.toXML[com.gu.nitf.model.Distributor](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("distributor"), __scope, false) } getOrElse {Nil},
        __obj.dateline flatMap { scalaxb.toXML[com.gu.nitf.model.Dateline](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("dateline"), __scope, false) },
        __obj.abstractValue map { scalaxb.toXML[com.gu.nitf.model.Abstract](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("abstract"), __scope, false) } getOrElse {Nil},
        __obj.series map { scalaxb.toXML[com.gu.nitf.model.Series](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("series"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultComgunitfmodel_HedlineFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Hedline] {
    override val defaultElementLabel: Option[String] = Some("hedline")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Hedline] =
      phrase((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "hl1")) ~ 
      safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "hl2")) ^^
      { case p1 ~ p2 =>
      com.gu.nitf.model.Hedline(scalaxb.fromXML[com.gu.nitf.model.Hl1](p1, scalaxb.ElemName(node) :: stack),
        p2 map { scalaxb.fromXML[com.gu.nitf.model.Hl2](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Hedline, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Hedline, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.gu.nitf.model.Hl1](__obj.hl1, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("hl1"), __scope, false),
        __obj.hl2 flatMap { scalaxb.toXML[com.gu.nitf.model.Hl2](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("hl2"), __scope, false) })

  }

  trait DefaultComgunitfmodel_Hl1Format extends scalaxb.ElemNameParser[com.gu.nitf.model.Hl1] with Comgunitfmodel_EnrichedTextGroupFormat {
    override val defaultElementLabel: Option[String] = Some("hl1")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Hl1] =
      phrase(optTextRecord ~ 
      safeRep((parsemixedEnrichedTextGroup(node, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Hl1(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Hl1, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Hl1, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_Hl2Format extends scalaxb.ElemNameParser[com.gu.nitf.model.Hl2] {
    override val defaultElementLabel: Option[String] = Some("hl2")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Hl2] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "chron")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Chron](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "classifier")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Classifier](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "copyrite")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Copyrite](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "event")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Event](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "function")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.FunctionType](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "location")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Location](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "money")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Money](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "num")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Num](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "object.title")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.ObjectTitle](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "org")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Org](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "person")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Person](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "postaddr")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Postaddr](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "virtloc")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Virtloc](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "a")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.A](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "br")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Br](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "em")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Em](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "lang")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Lang](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "pronounce")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Pronounce](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "q")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Q](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Hl2(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Hl2, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Hl2, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  def buildComgunitfmodel_NoteclassFormat = new DefaultComgunitfmodel_NoteclassFormat {}
  trait DefaultComgunitfmodel_NoteclassFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Noteclass] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("noteclass")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.Noteclass = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("cpyrt")) => com.gu.nitf.model.Cpyrt
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("end")) => com.gu.nitf.model.End
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("hd")) => com.gu.nitf.model.Hd
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("editorsnote")) => com.gu.nitf.model.Editorsnote
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("trademk")) => com.gu.nitf.model.Trademk
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("undef")) => com.gu.nitf.model.Undef

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Noteclass] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.Noteclass, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildComgunitfmodel_TypeType2Format = new DefaultComgunitfmodel_TypeType2Format {}
  trait DefaultComgunitfmodel_TypeType2Format extends scalaxb.XMLFormat[com.gu.nitf.model.TypeType2] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("type")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.TypeType2 = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("std")) => com.gu.nitf.model.Std
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("pa")) => com.gu.nitf.model.Pa
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("npa")) => com.gu.nitf.model.Npa

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.TypeType2] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.TypeType2, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultComgunitfmodel_NoteFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Note] {
    override val defaultElementLabel: Option[String] = Some("note")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Note] =
      phrase(safeRep(((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "body.content"))) ^^ 
        { case p1 => com.gu.nitf.model.NoteSequence1(scalaxb.fromXML[com.gu.nitf.model.BodyContent](p1, scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      com.gu.nitf.model.Note(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@noteclass").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Noteclass](x, scalaxb.ElemName(node) :: stack)) } map { "@noteclass" -> _ },
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.TypeType2](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[com.gu.nitf.model.TypeType2](scala.xml.Text("std"), scalaxb.ElemName(node) :: stack))) map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Note, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@noteclass", _) => __obj.noteclass foreach { x => attr = scala.xml.Attribute(null, "noteclass", x.toString, attr) }
        case ("@type", _) => if (__obj.typeValue.toString != "std") attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Note, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.notesequence1 flatMap { scalaxb.toXML[com.gu.nitf.model.NoteSequence1](_, None, Some("notesequence1"), __scope, false) })

  }

  trait DefaultComgunitfmodel_NoteSequence1Format extends scalaxb.XMLFormat[com.gu.nitf.model.NoteSequence1] {
    final override def defaultElementLabel: Option[String] = None  // sequences have no label
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.NoteSequence1] = Left("don't call me.")
    
    def writes(__obj: com.gu.nitf.model.NoteSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[com.gu.nitf.model.BodyContent](__obj.bodyContent, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("body.content"), __scope, false)


  }

  trait DefaultComgunitfmodel_RightsFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Rights] {
    override val defaultElementLabel: Option[String] = Some("rights")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Rights] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "rights.owner")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.RightsOwner](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "rights.startdate")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.RightsStartdate](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "rights.enddate")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.RightsEnddate](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "rights.agent")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.RightsAgent](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "rights.geography")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.RightsGeography](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "rights.type")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.RightsType](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "rights.limitations")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.RightsLimitations](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Rights(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Rights, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Rights, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_RightsOwnerFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.RightsOwner] {
    override val defaultElementLabel: Option[String] = Some("rights.owner")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.RightsOwner] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.RightsOwner(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@contact").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@contact" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.RightsOwner, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@contact", _) => __obj.contact foreach { x => attr = scala.xml.Attribute(null, "contact", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.RightsOwner, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_RightsStartdateFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.RightsStartdate] {
    override val defaultElementLabel: Option[String] = Some("rights.startdate")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.RightsStartdate] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.RightsStartdate(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@norm").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@norm" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.RightsStartdate, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@norm", _) => __obj.norm foreach { x => attr = scala.xml.Attribute(null, "norm", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.RightsStartdate, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_RightsEnddateFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.RightsEnddate] {
    override val defaultElementLabel: Option[String] = Some("rights.enddate")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.RightsEnddate] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.RightsEnddate(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@norm").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@norm" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.RightsEnddate, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@norm", _) => __obj.norm foreach { x => attr = scala.xml.Attribute(null, "norm", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.RightsEnddate, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_RightsAgentFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.RightsAgent] {
    override val defaultElementLabel: Option[String] = Some("rights.agent")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.RightsAgent] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.RightsAgent(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@contact").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@contact" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.RightsAgent, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@contact", _) => __obj.contact foreach { x => attr = scala.xml.Attribute(null, "contact", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.RightsAgent, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_RightsGeographyFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.RightsGeography] {
    override val defaultElementLabel: Option[String] = Some("rights.geography")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.RightsGeography] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.RightsGeography(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@location-code").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@location-code" -> _ },
        (node \ "@code-source").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@code-source" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.RightsGeography, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@location-code", _) => __obj.locationCode foreach { x => attr = scala.xml.Attribute(null, "location-code", x.toString, attr) }
        case ("@code-source", _) => __obj.codeSource foreach { x => attr = scala.xml.Attribute(null, "code-source", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.RightsGeography, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_RightsTypeFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.RightsType] {
    override val defaultElementLabel: Option[String] = Some("rights.type")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.RightsType] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.RightsType(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.RightsType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.RightsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_RightsLimitationsFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.RightsLimitations] {
    override val defaultElementLabel: Option[String] = Some("rights.limitations")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.RightsLimitations] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.RightsLimitations(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.RightsLimitations, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.RightsLimitations, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_BylineFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Byline] {
    override val defaultElementLabel: Option[String] = Some("byline")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Byline] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "person")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Person](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "byttl")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Byttl](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "location")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Location](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "virtloc")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Virtloc](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Byline(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Byline, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Byline, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_ByttlFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Byttl] {
    override val defaultElementLabel: Option[String] = Some("byttl")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Byttl] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "org")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Org](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Byttl(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Byttl, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Byttl, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_DistributorFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Distributor] {
    override val defaultElementLabel: Option[String] = Some("distributor")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Distributor] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "org")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Org](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Distributor(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Distributor, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Distributor, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_DatelineFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Dateline] {
    override val defaultElementLabel: Option[String] = Some("dateline")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Dateline] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "location")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Location](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "story.date")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.StoryDate](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Dateline(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Dateline, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Dateline, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_StoryDateFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.StoryDate] {
    override val defaultElementLabel: Option[String] = Some("story.date")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.StoryDate] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.StoryDate(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@norm").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@norm" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.StoryDate, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@norm", _) => __obj.norm foreach { x => attr = scala.xml.Attribute(null, "norm", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.StoryDate, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_AbstractFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Abstract] with Comgunitfmodel_BlockContentGroupFormat {
    override val defaultElementLabel: Option[String] = Some("abstract")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Abstract] =
      phrase(safeRep((parseBlockContentGroup(node, scalaxb.ElemName(node) :: stack, true))) ^^
      { case p1 =>
      com.gu.nitf.model.Abstract(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Abstract, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Abstract, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.abstractoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultComgunitfmodel_CopyriteFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Copyrite] {
    override val defaultElementLabel: Option[String] = Some("copyrite")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Copyrite] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "copyrite.year")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.CopyriteYear](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "copyrite.holder")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.CopyriteHolder](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Copyrite(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Copyrite, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Copyrite, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_CopyriteYearFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.CopyriteYear] {
    override val defaultElementLabel: Option[String] = Some("copyrite.year")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.CopyriteYear] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.CopyriteYear(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.CopyriteYear, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.CopyriteYear, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_CopyriteHolderFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.CopyriteHolder] {
    override val defaultElementLabel: Option[String] = Some("copyrite.holder")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.CopyriteHolder] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.CopyriteHolder(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.CopyriteHolder, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.CopyriteHolder, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_BodyContentFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.BodyContent] with Comgunitfmodel_BlockContentGroupFormat {
    override val defaultElementLabel: Option[String] = Some("body.content")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.BodyContent] =
      phrase(safeRep(((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "block")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Block](x, scalaxb.ElemName(node) :: stack)))) ||| 
      (parseBlockContentGroup(node, scalaxb.ElemName(node) :: stack, true))) ^^
      { case p1 =>
      com.gu.nitf.model.BodyContent(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.BodyContent, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.BodyContent, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.bodycontentoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultComgunitfmodel_BlockFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Block] with Comgunitfmodel_BlockContentGroupFormat {
    override val defaultElementLabel: Option[String] = Some("block")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Block] =
      phrase(opt((opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "tobject")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "key-list")) ~ 
      safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "classifier")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "byline")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "dateline")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "copyrite")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "abstract"))) ^^ 
        { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 => com.gu.nitf.model.BlockSequence1(p1.headOption map { scalaxb.fromXML[com.gu.nitf.model.Tobject](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[com.gu.nitf.model.KeyList](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[com.gu.nitf.model.Classifier](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.gu.nitf.model.Byline](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[com.gu.nitf.model.Dateline](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[com.gu.nitf.model.Copyrite](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[com.gu.nitf.model.Abstract](_, scalaxb.ElemName(node) :: stack) }) }) ~ 
      safeRep((parseBlockContentGroup(node, scalaxb.ElemName(node) :: stack, true))) ~ 
      opt((opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "datasource"))) ^^ 
        { case p1 => com.gu.nitf.model.BlockSequence2(p1.headOption map { scalaxb.fromXML[com.gu.nitf.model.Datasource](_, scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Block(p1,
        p2,
        p3,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Block, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Block, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.blocksequence1 map { scalaxb.toXML[com.gu.nitf.model.BlockSequence1](_, None, Some("blocksequence1"), __scope, false) } getOrElse {Nil},
        __obj.blockoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) },
        __obj.blocksequence2 map { scalaxb.toXML[com.gu.nitf.model.BlockSequence2](_, None, Some("blocksequence2"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultComgunitfmodel_BlockSequence2Format extends scalaxb.XMLFormat[com.gu.nitf.model.BlockSequence2] {
    final override def defaultElementLabel: Option[String] = None  // sequences have no label
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.BlockSequence2] = Left("don't call me.")
    
    def writes(__obj: com.gu.nitf.model.BlockSequence2, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      __obj.datasource map { scalaxb.toXML[com.gu.nitf.model.Datasource](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("datasource"), __scope, false) } getOrElse {Nil}


  }

  trait DefaultComgunitfmodel_BlockSequence1Format extends scalaxb.XMLFormat[com.gu.nitf.model.BlockSequence1] {
    final override def defaultElementLabel: Option[String] = None  // sequences have no label
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.BlockSequence1] = Left("don't call me.")
    
    def writes(__obj: com.gu.nitf.model.BlockSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.tobject map { scalaxb.toXML[com.gu.nitf.model.Tobject](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("tobject"), __scope, false) } getOrElse {Nil},
        __obj.keyList map { scalaxb.toXML[com.gu.nitf.model.KeyList](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("key-list"), __scope, false) } getOrElse {Nil},
        __obj.classifier flatMap { scalaxb.toXML[com.gu.nitf.model.Classifier](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("classifier"), __scope, false) },
        __obj.byline map { scalaxb.toXML[com.gu.nitf.model.Byline](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("byline"), __scope, false) } getOrElse {Nil},
        __obj.dateline map { scalaxb.toXML[com.gu.nitf.model.Dateline](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("dateline"), __scope, false) } getOrElse {Nil},
        __obj.copyrite map { scalaxb.toXML[com.gu.nitf.model.Copyrite](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("copyrite"), __scope, false) } getOrElse {Nil},
        __obj.abstractValue map { scalaxb.toXML[com.gu.nitf.model.Abstract](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("abstract"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultComgunitfmodel_PFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.P] {
    override val defaultElementLabel: Option[String] = Some("p")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.P] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "chron")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Chron](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "classifier")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Classifier](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "copyrite")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Copyrite](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "event")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Event](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "function")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.FunctionType](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "location")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Location](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "money")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Money](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "num")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Num](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "object.title")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.ObjectTitle](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "org")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Org](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "person")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Person](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "postaddr")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Postaddr](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "virtloc")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Virtloc](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "a")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.A](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "br")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Br](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "em")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Em](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "lang")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Lang](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "pronounce")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Pronounce](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "q")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Q](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.P(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@lede").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@lede" -> _ },
        (node \ "@summary").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@summary" -> _ },
        (node \ "@optional-text").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@optional-text" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.P, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@lede", _) => __obj.lede foreach { x => attr = scala.xml.Attribute(null, "lede", x.toString, attr) }
        case ("@summary", _) => __obj.summary foreach { x => attr = scala.xml.Attribute(null, "summary", x.toString, attr) }
        case ("@optional-text", _) => __obj.optionalText foreach { x => attr = scala.xml.Attribute(null, "optional-text", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.P, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  def buildComgunitfmodel_AlignTypeFormat = new DefaultComgunitfmodel_AlignTypeFormat {}
  trait DefaultComgunitfmodel_AlignTypeFormat extends scalaxb.XMLFormat[com.gu.nitf.model.AlignType] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("align")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.AlignType = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("left")) => com.gu.nitf.model.LeftTypeValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("center")) => com.gu.nitf.model.CenterValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("right")) => com.gu.nitf.model.RightTypeValue

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.AlignType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.AlignType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildComgunitfmodel_FrameFormat = new DefaultComgunitfmodel_FrameFormat {}
  trait DefaultComgunitfmodel_FrameFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Frame] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("frame")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.Frame = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("void")) => com.gu.nitf.model.Void
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("above")) => com.gu.nitf.model.Above
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("below")) => com.gu.nitf.model.Below
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("hsides")) => com.gu.nitf.model.Hsides
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("lhs")) => com.gu.nitf.model.Lhs
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("rhs")) => com.gu.nitf.model.Rhs
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("vsides")) => com.gu.nitf.model.Vsides
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("box")) => com.gu.nitf.model.Box
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("border")) => com.gu.nitf.model.Border

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Frame] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.Frame, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildComgunitfmodel_RulesFormat = new DefaultComgunitfmodel_RulesFormat {}
  trait DefaultComgunitfmodel_RulesFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Rules] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("rules")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.Rules = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => com.gu.nitf.model.NoneType
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("basic")) => com.gu.nitf.model.Basic
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("rows")) => com.gu.nitf.model.Rows
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("cols")) => com.gu.nitf.model.Cols
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("all")) => com.gu.nitf.model.AllType

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Rules] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.Rules, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultComgunitfmodel_TableFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Table] {
    override val defaultElementLabel: Option[String] = Some("table")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Table] =
      phrase(opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "caption")) ~ 
      opt(((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "col")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Col](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "colgroup")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Colgroup](x, scalaxb.ElemName(node) :: stack))))) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "thead")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "tfoot")) ~ 
      safeRep(((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "tbody")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Tbody](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "tr")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Tr](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      com.gu.nitf.model.Table(p1.headOption map { scalaxb.fromXML[com.gu.nitf.model.Caption](_, scalaxb.ElemName(node) :: stack) },
        p2,
        p3.headOption map { scalaxb.fromXML[com.gu.nitf.model.Thead](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.gu.nitf.model.Tfoot](_, scalaxb.ElemName(node) :: stack) },
        p5,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@tabletype").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@tabletype" -> _ },
        (node \ "@align").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.AlignType](x, scalaxb.ElemName(node) :: stack)) } map { "@align" -> _ },
        (node \ "@width").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@width" -> _ },
        (node \ "@cols").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@cols" -> _ },
        (node \ "@border").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@border" -> _ },
        (node \ "@frame").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Frame](x, scalaxb.ElemName(node) :: stack)) } map { "@frame" -> _ },
        (node \ "@rules").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Rules](x, scalaxb.ElemName(node) :: stack)) } map { "@rules" -> _ },
        (node \ "@cellspacing").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@cellspacing" -> _ },
        (node \ "@cellpadding").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@cellpadding" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Table, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@tabletype", _) => __obj.tabletype foreach { x => attr = scala.xml.Attribute(null, "tabletype", x.toString, attr) }
        case ("@align", _) => __obj.align foreach { x => attr = scala.xml.Attribute(null, "align", x.toString, attr) }
        case ("@width", _) => __obj.width foreach { x => attr = scala.xml.Attribute(null, "width", x.toString, attr) }
        case ("@cols", _) => __obj.cols foreach { x => attr = scala.xml.Attribute(null, "cols", x.toString, attr) }
        case ("@border", _) => __obj.border foreach { x => attr = scala.xml.Attribute(null, "border", x.toString, attr) }
        case ("@frame", _) => __obj.frame foreach { x => attr = scala.xml.Attribute(null, "frame", x.toString, attr) }
        case ("@rules", _) => __obj.rules foreach { x => attr = scala.xml.Attribute(null, "rules", x.toString, attr) }
        case ("@cellspacing", _) => __obj.cellspacing foreach { x => attr = scala.xml.Attribute(null, "cellspacing", x.toString, attr) }
        case ("@cellpadding", _) => __obj.cellpadding foreach { x => attr = scala.xml.Attribute(null, "cellpadding", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Table, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.caption map { scalaxb.toXML[com.gu.nitf.model.Caption](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("caption"), __scope, false) } getOrElse {Nil},
        __obj.tableoption map { x => scalaxb.toXML[scalaxb.DataRecord[com.gu.nitf.model.TableOption]](x, x.namespace, x.key, __scope, false) } getOrElse {Nil},
        __obj.thead map { scalaxb.toXML[com.gu.nitf.model.Thead](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("thead"), __scope, false) } getOrElse {Nil},
        __obj.tfoot map { scalaxb.toXML[com.gu.nitf.model.Tfoot](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("tfoot"), __scope, false) } getOrElse {Nil},
        __obj.tableoption2 flatMap { x => scalaxb.toXML[scalaxb.DataRecord[com.gu.nitf.model.TableOption2]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultComgunitfmodel_MediaFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Media] {
    override val defaultElementLabel: Option[String] = Some("media")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Media] =
      phrase(safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "media-metadata")) ~ 
      safeRep(((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "media-reference")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "media-object"))) ^^ 
        { case p1 ~ p2 => com.gu.nitf.model.MediaSequence1(scalaxb.fromXML[com.gu.nitf.model.MediaReference](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[com.gu.nitf.model.MediaObject](_, scalaxb.ElemName(node) :: stack) }) }) ~ 
      safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "media-caption")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "media-producer")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      com.gu.nitf.model.Media(p1 map { scalaxb.fromXML[com.gu.nitf.model.MediaMetadata](_, scalaxb.ElemName(node) :: stack) },
        p2,
        p3 map { scalaxb.fromXML[com.gu.nitf.model.MediaCaption](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.gu.nitf.model.MediaProducer](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@media-type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@media-type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Media, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@media-type", _) => attr = scala.xml.Attribute(null, "media-type", __obj.mediaType.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Media, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.mediaMetadata flatMap { scalaxb.toXML[com.gu.nitf.model.MediaMetadata](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("media-metadata"), __scope, false) },
        __obj.mediasequence1 flatMap { scalaxb.toXML[com.gu.nitf.model.MediaSequence1](_, None, Some("mediasequence1"), __scope, false) },
        __obj.mediaCaption flatMap { scalaxb.toXML[com.gu.nitf.model.MediaCaption](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("media-caption"), __scope, false) },
        __obj.mediaProducer map { scalaxb.toXML[com.gu.nitf.model.MediaProducer](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("media-producer"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultComgunitfmodel_MediaSequence1Format extends scalaxb.XMLFormat[com.gu.nitf.model.MediaSequence1] {
    final override def defaultElementLabel: Option[String] = None  // sequences have no label
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.MediaSequence1] = Left("don't call me.")
    
    def writes(__obj: com.gu.nitf.model.MediaSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[com.gu.nitf.model.MediaReference](__obj.mediaReference, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("media-reference"), __scope, false),
        __obj.mediaObject map { scalaxb.toXML[com.gu.nitf.model.MediaObject](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("media-object"), __scope, false) } getOrElse {Nil})


  }

  def buildComgunitfmodel_UnitsFormat = new DefaultComgunitfmodel_UnitsFormat {}
  trait DefaultComgunitfmodel_UnitsFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Units] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("units")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.Units = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("pixels")) => com.gu.nitf.model.Pixels

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Units] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.Units, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildComgunitfmodel_NoflowFormat = new DefaultComgunitfmodel_NoflowFormat {}
  trait DefaultComgunitfmodel_NoflowFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Noflow] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("noflow")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.Noflow = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("noflow")) => com.gu.nitf.model.NoflowValue

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Noflow] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.Noflow, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultComgunitfmodel_MediaReferenceFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.MediaReference] {
    override val defaultElementLabel: Option[String] = Some("media-reference")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.MediaReference] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.MediaReference(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@source").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@source" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@mime-type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@mime-type" -> _ },
        (node \ "@coding").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@coding" -> _ },
        (node \ "@time").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@time" -> _ },
        (node \ "@time-unit-of-measure").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@time-unit-of-measure" -> _ },
        (node \ "@outcue").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@outcue" -> _ },
        (node \ "@source-credit").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@source-credit" -> _ },
        (node \ "@copyright").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@copyright" -> _ },
        (node \ "@alternate-text").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@alternate-text" -> _ },
        (node \ "@height").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@height" -> _ },
        (node \ "@width").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@width" -> _ },
        (node \ "@units").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Units](x, scalaxb.ElemName(node) :: stack)) } map { "@units" -> _ },
        (node \ "@imagemap").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@imagemap" -> _ },
        (node \ "@noflow").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Noflow](x, scalaxb.ElemName(node) :: stack)) } map { "@noflow" -> _ },
        (node \ "@data-location").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@data-location" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.MediaReference, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@source", _) => __obj.source foreach { x => attr = scala.xml.Attribute(null, "source", x.toString, attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@mime-type", _) => __obj.mimeType foreach { x => attr = scala.xml.Attribute(null, "mime-type", x.toString, attr) }
        case ("@coding", _) => __obj.coding foreach { x => attr = scala.xml.Attribute(null, "coding", x.toString, attr) }
        case ("@time", _) => __obj.time foreach { x => attr = scala.xml.Attribute(null, "time", x.toString, attr) }
        case ("@time-unit-of-measure", _) => __obj.timeUnitOfMeasure foreach { x => attr = scala.xml.Attribute(null, "time-unit-of-measure", x.toString, attr) }
        case ("@outcue", _) => __obj.outcue foreach { x => attr = scala.xml.Attribute(null, "outcue", x.toString, attr) }
        case ("@source-credit", _) => __obj.sourceCredit foreach { x => attr = scala.xml.Attribute(null, "source-credit", x.toString, attr) }
        case ("@copyright", _) => __obj.copyright foreach { x => attr = scala.xml.Attribute(null, "copyright", x.toString, attr) }
        case ("@alternate-text", _) => __obj.alternateText foreach { x => attr = scala.xml.Attribute(null, "alternate-text", x.toString, attr) }
        case ("@height", _) => __obj.height foreach { x => attr = scala.xml.Attribute(null, "height", x.toString, attr) }
        case ("@width", _) => __obj.width foreach { x => attr = scala.xml.Attribute(null, "width", x.toString, attr) }
        case ("@units", _) => __obj.units foreach { x => attr = scala.xml.Attribute(null, "units", x.toString, attr) }
        case ("@imagemap", _) => __obj.imagemap foreach { x => attr = scala.xml.Attribute(null, "imagemap", x.toString, attr) }
        case ("@noflow", _) => __obj.noflow foreach { x => attr = scala.xml.Attribute(null, "noflow", x.toString, attr) }
        case ("@data-location", _) => __obj.dataLocation foreach { x => attr = scala.xml.Attribute(null, "data-location", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.MediaReference, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_MediaMetadataFormat extends scalaxb.XMLFormat[com.gu.nitf.model.MediaMetadata] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.MediaMetadata] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("media-metadata")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.MediaMetadata] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.MediaMetadata(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.MediaMetadata, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.MediaMetadata, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_MediaObjectFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.MediaObject] {
    override val defaultElementLabel: Option[String] = Some("media-object")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.MediaObject] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.MediaObject(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@encoding").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@encoding" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.MediaObject, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@encoding", _) => attr = scala.xml.Attribute(null, "encoding", __obj.encoding.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.MediaObject, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_MediaCaptionFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.MediaCaption] with Comgunitfmodel_EnrichedTextGroupFormat with Comgunitfmodel_BlockContentGroupFormat {
    override val defaultElementLabel: Option[String] = Some("media-caption")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.MediaCaption] =
      phrase(optTextRecord ~ 
      safeRep((parsemixedEnrichedTextGroup(node, scalaxb.ElemName(node) :: stack)) ||| 
      (parsemixedBlockContentGroup(node, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.MediaCaption(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.MediaCaption, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.MediaCaption, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_MediaProducerFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.MediaProducer] with Comgunitfmodel_EnrichedTextGroupFormat {
    override val defaultElementLabel: Option[String] = Some("media-producer")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.MediaProducer] =
      phrase(optTextRecord ~ 
      safeRep((parsemixedEnrichedTextGroup(node, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.MediaProducer(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.MediaProducer, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.MediaProducer, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_OlFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Ol] {
    override val defaultElementLabel: Option[String] = Some("ol")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Ol] =
      phrase(safeRep(((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "li"))) ^^ 
        { case p1 => com.gu.nitf.model.OlSequence1(scalaxb.fromXML[com.gu.nitf.model.Li](p1, scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      com.gu.nitf.model.Ol(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@seqnum").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@seqnum" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Ol, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@seqnum", _) => __obj.seqnum foreach { x => attr = scala.xml.Attribute(null, "seqnum", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Ol, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.olsequence1 flatMap { scalaxb.toXML[com.gu.nitf.model.OlSequence1](_, None, Some("olsequence1"), __scope, false) })

  }

  trait DefaultComgunitfmodel_OlSequence1Format extends scalaxb.XMLFormat[com.gu.nitf.model.OlSequence1] {
    final override def defaultElementLabel: Option[String] = None  // sequences have no label
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.OlSequence1] = Left("don't call me.")
    
    def writes(__obj: com.gu.nitf.model.OlSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[com.gu.nitf.model.Li](__obj.li, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("li"), __scope, false)


  }

  trait DefaultComgunitfmodel_UlFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Ul] {
    override val defaultElementLabel: Option[String] = Some("ul")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Ul] =
      phrase(safeRep(((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "li"))) ^^ 
        { case p1 => com.gu.nitf.model.UlSequence1(scalaxb.fromXML[com.gu.nitf.model.Li](p1, scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      com.gu.nitf.model.Ul(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Ul, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Ul, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.ulsequence1 flatMap { scalaxb.toXML[com.gu.nitf.model.UlSequence1](_, None, Some("ulsequence1"), __scope, false) })

  }

  trait DefaultComgunitfmodel_UlSequence1Format extends scalaxb.XMLFormat[com.gu.nitf.model.UlSequence1] {
    final override def defaultElementLabel: Option[String] = None  // sequences have no label
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.UlSequence1] = Left("don't call me.")
    
    def writes(__obj: com.gu.nitf.model.UlSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[com.gu.nitf.model.Li](__obj.li, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("li"), __scope, false)


  }

  trait DefaultComgunitfmodel_LiFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Li] with Comgunitfmodel_EnrichedTextGroupFormat with Comgunitfmodel_BlockContentGroupFormat {
    override val defaultElementLabel: Option[String] = Some("li")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Li] =
      phrase(optTextRecord ~ 
      safeRep((parsemixedEnrichedTextGroup(node, scalaxb.ElemName(node) :: stack)) ||| 
      (parsemixedBlockContentGroup(node, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Li(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Li, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Li, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_DlFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Dl] {
    override val defaultElementLabel: Option[String] = Some("dl")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Dl] =
      phrase(safeRep(((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "dt")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Dt](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "dd")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Dd](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      com.gu.nitf.model.Dl(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Dl, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Dl, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.dloption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[com.gu.nitf.model.DlOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultComgunitfmodel_DtFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Dt] with Comgunitfmodel_EnrichedTextGroupFormat {
    override val defaultElementLabel: Option[String] = Some("dt")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Dt] =
      phrase(optTextRecord ~ 
      safeRep((parsemixedEnrichedTextGroup(node, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Dt(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Dt, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Dt, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_DdFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Dd] with Comgunitfmodel_EnrichedTextGroupFormat with Comgunitfmodel_BlockContentGroupFormat {
    override val defaultElementLabel: Option[String] = Some("dd")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Dd] =
      phrase(safeRep((parseEnrichedTextGroup(node, scalaxb.ElemName(node) :: stack, true)) ||| 
      (parseBlockContentGroup(node, scalaxb.ElemName(node) :: stack, true)) ||| 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "block")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Block](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      com.gu.nitf.model.Dd(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Dd, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Dd, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.ddoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) })

  }

  def buildComgunitfmodel_NowrapFormat = new DefaultComgunitfmodel_NowrapFormat {}
  trait DefaultComgunitfmodel_NowrapFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Nowrap] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("nowrap")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.Nowrap = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("nowrap")) => com.gu.nitf.model.NowrapValue

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Nowrap] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.Nowrap, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultComgunitfmodel_BqFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Bq] {
    override val defaultElementLabel: Option[String] = Some("bq")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Bq] =
      phrase(safeRep((safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "block")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "credit"))) ^^ 
        { case p1 ~ p2 => com.gu.nitf.model.BqSequence1(p1 map { scalaxb.fromXML[com.gu.nitf.model.Block](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[com.gu.nitf.model.Credit](_, scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 =>
      com.gu.nitf.model.Bq(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@nowrap").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Nowrap](x, scalaxb.ElemName(node) :: stack)) } map { "@nowrap" -> _ },
        (node \ "@quote-source").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@quote-source" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Bq, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@nowrap", _) => __obj.nowrap foreach { x => attr = scala.xml.Attribute(null, "nowrap", x.toString, attr) }
        case ("@quote-source", _) => __obj.quoteSource foreach { x => attr = scala.xml.Attribute(null, "quote-source", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Bq, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.bqsequence1 flatMap { scalaxb.toXML[com.gu.nitf.model.BqSequence1](_, None, Some("bqsequence1"), __scope, false) })

  }

  trait DefaultComgunitfmodel_BqSequence1Format extends scalaxb.XMLFormat[com.gu.nitf.model.BqSequence1] {
    final override def defaultElementLabel: Option[String] = None  // sequences have no label
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.BqSequence1] = Left("don't call me.")
    
    def writes(__obj: com.gu.nitf.model.BqSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(__obj.block flatMap { scalaxb.toXML[com.gu.nitf.model.Block](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("block"), __scope, false) },
        __obj.credit map { scalaxb.toXML[com.gu.nitf.model.Credit](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("credit"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultComgunitfmodel_CreditFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Credit] with Comgunitfmodel_EnrichedTextGroupFormat {
    override val defaultElementLabel: Option[String] = Some("credit")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Credit] =
      phrase(optTextRecord ~ 
      safeRep((parsemixedEnrichedTextGroup(node, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Credit(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Credit, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Credit, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_FnFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Fn] {
    override val defaultElementLabel: Option[String] = Some("fn")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Fn] =
      phrase(safeRep(((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "body.content"))) ^^ 
        { case p1 => com.gu.nitf.model.FnSequence1(scalaxb.fromXML[com.gu.nitf.model.BodyContent](p1, scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      com.gu.nitf.model.Fn(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Fn, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Fn, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.fnsequence1 flatMap { scalaxb.toXML[com.gu.nitf.model.FnSequence1](_, None, Some("fnsequence1"), __scope, false) })

  }

  trait DefaultComgunitfmodel_FnSequence1Format extends scalaxb.XMLFormat[com.gu.nitf.model.FnSequence1] {
    final override def defaultElementLabel: Option[String] = None  // sequences have no label
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.FnSequence1] = Left("don't call me.")
    
    def writes(__obj: com.gu.nitf.model.FnSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[com.gu.nitf.model.BodyContent](__obj.bodyContent, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("body.content"), __scope, false)


  }

  trait DefaultComgunitfmodel_PreFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Pre] {
    override val defaultElementLabel: Option[String] = Some("pre")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Pre] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.Pre(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Pre, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Pre, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_HrFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Hr] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.Hr] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("hr")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Hr] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.Hr(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.Hr, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Hr, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_DatasourceFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Datasource] {
    override val defaultElementLabel: Option[String] = Some("datasource")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Datasource] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.Datasource(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Datasource, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Datasource, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  def buildComgunitfmodel_AlignType2Format = new DefaultComgunitfmodel_AlignType2Format {}
  trait DefaultComgunitfmodel_AlignType2Format extends scalaxb.XMLFormat[com.gu.nitf.model.AlignType2] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("align")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.AlignType2 = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("top")) => com.gu.nitf.model.TopValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("bottom")) => com.gu.nitf.model.BottomValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("left")) => com.gu.nitf.model.LeftTypeValue2
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("right")) => com.gu.nitf.model.RightTypeValue2

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.AlignType2] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.AlignType2, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultComgunitfmodel_CaptionFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Caption] with Comgunitfmodel_EnrichedTextGroupFormat with Comgunitfmodel_BlockContentGroupFormat {
    override val defaultElementLabel: Option[String] = Some("caption")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Caption] =
      phrase(optTextRecord ~ 
      safeRep((parsemixedEnrichedTextGroup(node, scalaxb.ElemName(node) :: stack)) ||| 
      (parsemixedBlockContentGroup(node, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Caption(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@align").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.AlignType2](x, scalaxb.ElemName(node) :: stack)) } map { "@align" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Caption, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@align", _) => __obj.align foreach { x => attr = scala.xml.Attribute(null, "align", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Caption, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_ColFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Col] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.Col] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("col")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Col] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.Col(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@span").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("1"), scalaxb.ElemName(node) :: stack))) map { "@span" -> _ },
        (node \ "@width").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@width" -> _ },
        (node \ "@align").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Align](x, scalaxb.ElemName(node) :: stack)) } map { "@align" -> _ },
        (node \ "@char").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@char" -> _ },
        (node \ "@charoff").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@charoff" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.Col, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@span", _) => if (__obj.span.toString != "1") attr = scala.xml.Attribute(null, "span", __obj.span.toString, attr)
        case ("@width", _) => __obj.width foreach { x => attr = scala.xml.Attribute(null, "width", x.toString, attr) }
        case ("@align", _) => __obj.align foreach { x => attr = scala.xml.Attribute(null, "align", x.toString, attr) }
        case ("@char", _) => __obj.char foreach { x => attr = scala.xml.Attribute(null, "char", x.toString, attr) }
        case ("@charoff", _) => __obj.charoff foreach { x => attr = scala.xml.Attribute(null, "charoff", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Col, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_ColgroupFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Colgroup] {
    override val defaultElementLabel: Option[String] = Some("colgroup")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Colgroup] =
      phrase(safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "col")) ^^
      { case p1 =>
      com.gu.nitf.model.Colgroup(p1 map { scalaxb.fromXML[com.gu.nitf.model.Col](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@align").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Align](x, scalaxb.ElemName(node) :: stack)) } map { "@align" -> _ },
        (node \ "@char").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@char" -> _ },
        (node \ "@charoff").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@charoff" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Colgroup, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@align", _) => __obj.align foreach { x => attr = scala.xml.Attribute(null, "align", x.toString, attr) }
        case ("@char", _) => __obj.char foreach { x => attr = scala.xml.Attribute(null, "char", x.toString, attr) }
        case ("@charoff", _) => __obj.charoff foreach { x => attr = scala.xml.Attribute(null, "charoff", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Colgroup, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.col flatMap { scalaxb.toXML[com.gu.nitf.model.Col](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("col"), __scope, false) })

  }

  trait DefaultComgunitfmodel_TheadFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Thead] {
    override val defaultElementLabel: Option[String] = Some("thead")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Thead] =
      phrase(safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "tr")) ^^
      { case p1 =>
      com.gu.nitf.model.Thead(p1 map { scalaxb.fromXML[com.gu.nitf.model.Tr](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@align").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Align](x, scalaxb.ElemName(node) :: stack)) } map { "@align" -> _ },
        (node \ "@char").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@char" -> _ },
        (node \ "@charoff").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@charoff" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Thead, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@align", _) => __obj.align foreach { x => attr = scala.xml.Attribute(null, "align", x.toString, attr) }
        case ("@char", _) => __obj.char foreach { x => attr = scala.xml.Attribute(null, "char", x.toString, attr) }
        case ("@charoff", _) => __obj.charoff foreach { x => attr = scala.xml.Attribute(null, "charoff", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Thead, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.tr flatMap { scalaxb.toXML[com.gu.nitf.model.Tr](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("tr"), __scope, false) })

  }

  trait DefaultComgunitfmodel_TbodyFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Tbody] {
    override val defaultElementLabel: Option[String] = Some("tbody")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Tbody] =
      phrase(safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "tr")) ^^
      { case p1 =>
      com.gu.nitf.model.Tbody(p1 map { scalaxb.fromXML[com.gu.nitf.model.Tr](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@align").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Align](x, scalaxb.ElemName(node) :: stack)) } map { "@align" -> _ },
        (node \ "@char").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@char" -> _ },
        (node \ "@charoff").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@charoff" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Tbody, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@align", _) => __obj.align foreach { x => attr = scala.xml.Attribute(null, "align", x.toString, attr) }
        case ("@char", _) => __obj.char foreach { x => attr = scala.xml.Attribute(null, "char", x.toString, attr) }
        case ("@charoff", _) => __obj.charoff foreach { x => attr = scala.xml.Attribute(null, "charoff", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Tbody, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.tr flatMap { scalaxb.toXML[com.gu.nitf.model.Tr](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("tr"), __scope, false) })

  }

  trait DefaultComgunitfmodel_TfootFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Tfoot] {
    override val defaultElementLabel: Option[String] = Some("tfoot")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Tfoot] =
      phrase(safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "tr")) ^^
      { case p1 =>
      com.gu.nitf.model.Tfoot(p1 map { scalaxb.fromXML[com.gu.nitf.model.Tr](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@align").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Align](x, scalaxb.ElemName(node) :: stack)) } map { "@align" -> _ },
        (node \ "@char").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@char" -> _ },
        (node \ "@charoff").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@charoff" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Tfoot, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@align", _) => __obj.align foreach { x => attr = scala.xml.Attribute(null, "align", x.toString, attr) }
        case ("@char", _) => __obj.char foreach { x => attr = scala.xml.Attribute(null, "char", x.toString, attr) }
        case ("@charoff", _) => __obj.charoff foreach { x => attr = scala.xml.Attribute(null, "charoff", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Tfoot, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.tr flatMap { scalaxb.toXML[com.gu.nitf.model.Tr](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("tr"), __scope, false) })

  }

  trait DefaultComgunitfmodel_TrFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Tr] {
    override val defaultElementLabel: Option[String] = Some("tr")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Tr] =
      phrase(safeRep(((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "th")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Th](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "td")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Td](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 =>
      com.gu.nitf.model.Tr(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@align").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Align](x, scalaxb.ElemName(node) :: stack)) } map { "@align" -> _ },
        (node \ "@char").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@char" -> _ },
        (node \ "@charoff").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@charoff" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Tr, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@align", _) => __obj.align foreach { x => attr = scala.xml.Attribute(null, "align", x.toString, attr) }
        case ("@char", _) => __obj.char foreach { x => attr = scala.xml.Attribute(null, "char", x.toString, attr) }
        case ("@charoff", _) => __obj.charoff foreach { x => attr = scala.xml.Attribute(null, "charoff", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Tr, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.troption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[com.gu.nitf.model.TrOption]](x, x.namespace, x.key, __scope, false) })

  }

  def buildComgunitfmodel_NowrapTypeFormat = new DefaultComgunitfmodel_NowrapTypeFormat {}
  trait DefaultComgunitfmodel_NowrapTypeFormat extends scalaxb.XMLFormat[com.gu.nitf.model.NowrapType] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("nowrap")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.NowrapType = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("nowrap")) => com.gu.nitf.model.NowrapValue2

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.NowrapType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.NowrapType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultComgunitfmodel_ThFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Th] with Comgunitfmodel_EnrichedTextGroupFormat with Comgunitfmodel_BlockContentGroupFormat {
    override val defaultElementLabel: Option[String] = Some("th")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Th] =
      phrase(optTextRecord ~ 
      safeRep((parsemixedEnrichedTextGroup(node, scalaxb.ElemName(node) :: stack)) ||| 
      (parsemixedBlockContentGroup(node, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Th(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@axis").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@axis" -> _ },
        (node \ "@axes").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@axes" -> _ },
        (node \ "@nowrap").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.NowrapType](x, scalaxb.ElemName(node) :: stack)) } map { "@nowrap" -> _ },
        (node \ "@rowspan").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@rowspan" -> _ },
        (node \ "@colspan").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@colspan" -> _ },
        (node \ "@align").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Align](x, scalaxb.ElemName(node) :: stack)) } map { "@align" -> _ },
        (node \ "@char").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@char" -> _ },
        (node \ "@charoff").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@charoff" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Th, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@axis", _) => __obj.axis foreach { x => attr = scala.xml.Attribute(null, "axis", x.toString, attr) }
        case ("@axes", _) => __obj.axes foreach { x => attr = scala.xml.Attribute(null, "axes", x.toString, attr) }
        case ("@nowrap", _) => __obj.nowrap foreach { x => attr = scala.xml.Attribute(null, "nowrap", x.toString, attr) }
        case ("@rowspan", _) => __obj.rowspan foreach { x => attr = scala.xml.Attribute(null, "rowspan", x.toString, attr) }
        case ("@colspan", _) => __obj.colspan foreach { x => attr = scala.xml.Attribute(null, "colspan", x.toString, attr) }
        case ("@align", _) => __obj.align foreach { x => attr = scala.xml.Attribute(null, "align", x.toString, attr) }
        case ("@char", _) => __obj.char foreach { x => attr = scala.xml.Attribute(null, "char", x.toString, attr) }
        case ("@charoff", _) => __obj.charoff foreach { x => attr = scala.xml.Attribute(null, "charoff", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Th, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  def buildComgunitfmodel_NowrapType2Format = new DefaultComgunitfmodel_NowrapType2Format {}
  trait DefaultComgunitfmodel_NowrapType2Format extends scalaxb.XMLFormat[com.gu.nitf.model.NowrapType2] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("nowrap")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.NowrapType2 = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("nowrap")) => com.gu.nitf.model.NowrapValue3

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.NowrapType2] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.NowrapType2, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultComgunitfmodel_TdFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Td] with Comgunitfmodel_EnrichedTextGroupFormat with Comgunitfmodel_BlockContentGroupFormat {
    override val defaultElementLabel: Option[String] = Some("td")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Td] =
      phrase(optTextRecord ~ 
      safeRep((parsemixedEnrichedTextGroup(node, scalaxb.ElemName(node) :: stack)) ||| 
      (parsemixedBlockContentGroup(node, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Td(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@axis").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@axis" -> _ },
        (node \ "@axes").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@axes" -> _ },
        (node \ "@nowrap").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.NowrapType2](x, scalaxb.ElemName(node) :: stack)) } map { "@nowrap" -> _ },
        (node \ "@rowspan").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@rowspan" -> _ },
        (node \ "@colspan").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@colspan" -> _ },
        (node \ "@align").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Align](x, scalaxb.ElemName(node) :: stack)) } map { "@align" -> _ },
        (node \ "@char").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@char" -> _ },
        (node \ "@charoff").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@charoff" -> _ },
        (node \ "@valign").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Valign](x, scalaxb.ElemName(node) :: stack)) } map { "@valign" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Td, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@axis", _) => __obj.axis foreach { x => attr = scala.xml.Attribute(null, "axis", x.toString, attr) }
        case ("@axes", _) => __obj.axes foreach { x => attr = scala.xml.Attribute(null, "axes", x.toString, attr) }
        case ("@nowrap", _) => __obj.nowrap foreach { x => attr = scala.xml.Attribute(null, "nowrap", x.toString, attr) }
        case ("@rowspan", _) => __obj.rowspan foreach { x => attr = scala.xml.Attribute(null, "rowspan", x.toString, attr) }
        case ("@colspan", _) => __obj.colspan foreach { x => attr = scala.xml.Attribute(null, "colspan", x.toString, attr) }
        case ("@align", _) => __obj.align foreach { x => attr = scala.xml.Attribute(null, "align", x.toString, attr) }
        case ("@char", _) => __obj.char foreach { x => attr = scala.xml.Attribute(null, "char", x.toString, attr) }
        case ("@charoff", _) => __obj.charoff foreach { x => attr = scala.xml.Attribute(null, "charoff", x.toString, attr) }
        case ("@valign", _) => __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Td, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_ChronFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Chron] {
    override val defaultElementLabel: Option[String] = Some("chron")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Chron] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.Chron(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@norm").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@norm" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Chron, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@norm", _) => __obj.norm foreach { x => attr = scala.xml.Attribute(null, "norm", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Chron, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_EventFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Event] {
    override val defaultElementLabel: Option[String] = Some("event")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Event] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "alt-code")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.AltCode](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Event(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@start-date").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@start-date" -> _ },
        (node \ "@end-date").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@end-date" -> _ },
        (node \ "@idsrc").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@idsrc" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Event, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@start-date", _) => __obj.startDate foreach { x => attr = scala.xml.Attribute(null, "start-date", x.toString, attr) }
        case ("@end-date", _) => __obj.endDate foreach { x => attr = scala.xml.Attribute(null, "end-date", x.toString, attr) }
        case ("@idsrc", _) => __obj.idsrc foreach { x => attr = scala.xml.Attribute(null, "idsrc", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Event, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_FunctionTypeFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.FunctionType] {
    override val defaultElementLabel: Option[String] = Some("function")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.FunctionType] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "alt-code")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.AltCode](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.FunctionType(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@idsrc").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@idsrc" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.FunctionType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@idsrc", _) => __obj.idsrc foreach { x => attr = scala.xml.Attribute(null, "idsrc", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.FunctionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_LocationFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Location] {
    override val defaultElementLabel: Option[String] = Some("location")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Location] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "sublocation")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Sublocation](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "city")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.City](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "state")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.State](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "region")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Region](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "country")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Country](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "alt-code")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.AltCode](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Location(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@location-code").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@location-code" -> _ },
        (node \ "@code-source").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@code-source" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Location, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@location-code", _) => __obj.locationCode foreach { x => attr = scala.xml.Attribute(null, "location-code", x.toString, attr) }
        case ("@code-source", _) => __obj.codeSource foreach { x => attr = scala.xml.Attribute(null, "code-source", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Location, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_SublocationFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Sublocation] {
    override val defaultElementLabel: Option[String] = Some("sublocation")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Sublocation] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "alt-code")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.AltCode](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Sublocation(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@location-code").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@location-code" -> _ },
        (node \ "@code-source").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@code-source" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Sublocation, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@location-code", _) => __obj.locationCode foreach { x => attr = scala.xml.Attribute(null, "location-code", x.toString, attr) }
        case ("@code-source", _) => __obj.codeSource foreach { x => attr = scala.xml.Attribute(null, "code-source", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Sublocation, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_CityFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.City] {
    override val defaultElementLabel: Option[String] = Some("city")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.City] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "alt-code")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.AltCode](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.City(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@city-code").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@city-code" -> _ },
        (node \ "@code-source").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@code-source" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.City, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@city-code", _) => __obj.cityCode foreach { x => attr = scala.xml.Attribute(null, "city-code", x.toString, attr) }
        case ("@code-source", _) => __obj.codeSource foreach { x => attr = scala.xml.Attribute(null, "code-source", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.City, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_StateFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.State] {
    override val defaultElementLabel: Option[String] = Some("state")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.State] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "alt-code")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.AltCode](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.State(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@state-code").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@state-code" -> _ },
        (node \ "@code-source").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@code-source" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.State, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@state-code", _) => __obj.stateCode foreach { x => attr = scala.xml.Attribute(null, "state-code", x.toString, attr) }
        case ("@code-source", _) => __obj.codeSource foreach { x => attr = scala.xml.Attribute(null, "code-source", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.State, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_RegionFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Region] {
    override val defaultElementLabel: Option[String] = Some("region")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Region] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "alt-code")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.AltCode](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Region(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@region-code").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@region-code" -> _ },
        (node \ "@code-source").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@code-source" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Region, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@region-code", _) => __obj.regionCode foreach { x => attr = scala.xml.Attribute(null, "region-code", x.toString, attr) }
        case ("@code-source", _) => __obj.codeSource foreach { x => attr = scala.xml.Attribute(null, "code-source", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Region, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_CountryFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Country] {
    override val defaultElementLabel: Option[String] = Some("country")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Country] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "alt-code")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.AltCode](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Country(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@iso-cc").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@iso-cc" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Country, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@iso-cc", _) => __obj.isoCc foreach { x => attr = scala.xml.Attribute(null, "iso-cc", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Country, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_MoneyFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Money] {
    override val defaultElementLabel: Option[String] = Some("money")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Money] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.Money(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@unit").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@unit" -> _ },
        (node \ "@date").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@date" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Money, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@unit", _) => __obj.unit foreach { x => attr = scala.xml.Attribute(null, "unit", x.toString, attr) }
        case ("@date", _) => __obj.date foreach { x => attr = scala.xml.Attribute(null, "date", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Money, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_NumFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Num] {
    override val defaultElementLabel: Option[String] = Some("num")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Num] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "frac")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Frac](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "sub")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Sub](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "sup")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Sup](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Num(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@units").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@units" -> _ },
        (node \ "@decimal-ch").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@decimal-ch" -> _ },
        (node \ "@thousands-ch").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@thousands-ch" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Num, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@units", _) => __obj.units foreach { x => attr = scala.xml.Attribute(null, "units", x.toString, attr) }
        case ("@decimal-ch", _) => __obj.decimalCh foreach { x => attr = scala.xml.Attribute(null, "decimal-ch", x.toString, attr) }
        case ("@thousands-ch", _) => __obj.thousandsCh foreach { x => attr = scala.xml.Attribute(null, "thousands-ch", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Num, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_FracFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Frac] {
    override val defaultElementLabel: Option[String] = Some("frac")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Frac] =
      phrase((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "numer")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "frac-sep")) ~ 
      (scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "denom")) ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Frac(scalaxb.fromXML[com.gu.nitf.model.Numer](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[com.gu.nitf.model.FracSep](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[com.gu.nitf.model.Denom](p3, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Frac, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Frac, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.gu.nitf.model.Numer](__obj.numer, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("numer"), __scope, false),
        __obj.fracSep map { scalaxb.toXML[com.gu.nitf.model.FracSep](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("frac-sep"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[com.gu.nitf.model.Denom](__obj.denom, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("denom"), __scope, false))

  }

  trait DefaultComgunitfmodel_NumerFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Numer] {
    override val defaultElementLabel: Option[String] = Some("numer")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Numer] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.Numer(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Numer, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Numer, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_FracSepFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.FracSep] {
    override val defaultElementLabel: Option[String] = Some("frac-sep")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.FracSep] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.FracSep(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.FracSep, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.FracSep, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_DenomFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Denom] {
    override val defaultElementLabel: Option[String] = Some("denom")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Denom] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.Denom(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Denom, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Denom, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_SubFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Sub] {
    override val defaultElementLabel: Option[String] = Some("sub")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Sub] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.Sub(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Sub, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Sub, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_SupFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Sup] {
    override val defaultElementLabel: Option[String] = Some("sup")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Sup] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.Sup(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Sup, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Sup, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_ObjectTitleFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.ObjectTitle] {
    override val defaultElementLabel: Option[String] = Some("object.title")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.ObjectTitle] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "alt-code")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.AltCode](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.ObjectTitle(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@idsrc").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@idsrc" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.ObjectTitle, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@idsrc", _) => __obj.idsrc foreach { x => attr = scala.xml.Attribute(null, "idsrc", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.ObjectTitle, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_OrgFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Org] {
    override val defaultElementLabel: Option[String] = Some("org")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Org] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "alt-code")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.AltCode](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Org(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@idsrc").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@idsrc" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Org, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@idsrc", _) => __obj.idsrc foreach { x => attr = scala.xml.Attribute(null, "idsrc", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Org, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_AltCodeFormat extends scalaxb.XMLFormat[com.gu.nitf.model.AltCode] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.AltCode] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("alt-code")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.AltCode] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.AltCode(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@idsrc").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@idsrc" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.AltCode, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@idsrc", _) => attr = scala.xml.Attribute(null, "idsrc", __obj.idsrc.toString, attr)
        case ("@value", _) => attr = scala.xml.Attribute(null, "value", __obj.valueAttribute.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.AltCode, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  def buildComgunitfmodel_GenderFormat = new DefaultComgunitfmodel_GenderFormat {}
  trait DefaultComgunitfmodel_GenderFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Gender] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("gender")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.Gender = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("male")) => com.gu.nitf.model.Male
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("female")) => com.gu.nitf.model.Female

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Gender] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.Gender, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultComgunitfmodel_PersonFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Person] {
    override val defaultElementLabel: Option[String] = Some("person")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Person] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "name.given")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.NameGiven](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "name.family")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.NameFamily](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "function")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.FunctionType](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "alt-code")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.AltCode](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Person(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@idsrc").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@idsrc" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ },
        (node \ "@gender").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Gender](x, scalaxb.ElemName(node) :: stack)) } map { "@gender" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Person, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@idsrc", _) => __obj.idsrc foreach { x => attr = scala.xml.Attribute(null, "idsrc", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case ("@gender", _) => __obj.gender foreach { x => attr = scala.xml.Attribute(null, "gender", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Person, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_NameGivenFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.NameGiven] {
    override val defaultElementLabel: Option[String] = Some("name.given")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.NameGiven] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.NameGiven(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.NameGiven, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.NameGiven, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_NameFamilyFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.NameFamily] {
    override val defaultElementLabel: Option[String] = Some("name.family")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.NameFamily] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.NameFamily(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.NameFamily, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.NameFamily, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_PostaddrFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Postaddr] {
    override val defaultElementLabel: Option[String] = Some("postaddr")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Postaddr] =
      phrase((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "addressee")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "delivery.point")) ~ 
      safeRep(((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "postcode")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Postcode](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "delivery.office")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.DeliveryOffice](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "region")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Region](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "country")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Country](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Postaddr(scalaxb.fromXML[com.gu.nitf.model.Addressee](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[com.gu.nitf.model.DeliveryPoint](_, scalaxb.ElemName(node) :: stack) },
        p3,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Postaddr, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Postaddr, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.gu.nitf.model.Addressee](__obj.addressee, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("addressee"), __scope, false),
        __obj.deliveryPoint map { scalaxb.toXML[com.gu.nitf.model.DeliveryPoint](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("delivery.point"), __scope, false) } getOrElse {Nil},
        __obj.postaddroption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[com.gu.nitf.model.PostaddrOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultComgunitfmodel_VirtlocFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Virtloc] {
    override val defaultElementLabel: Option[String] = Some("virtloc")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Virtloc] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "alt-code")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.AltCode](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Virtloc(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@idsrc").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@idsrc" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Virtloc, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@idsrc", _) => __obj.idsrc foreach { x => attr = scala.xml.Attribute(null, "idsrc", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Virtloc, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_AFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.A] with Comgunitfmodel_EnrichedTextGroupFormat {
    override val defaultElementLabel: Option[String] = Some("a")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.A] =
      phrase(optTextRecord ~ 
      safeRep((parsemixedEnrichedTextGroup(node, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.A(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@href").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@href" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@rel").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@rel" -> _ },
        (node \ "@rev").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@rev" -> _ },
        (node \ "@title").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@title" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.A, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@href", _) => __obj.href foreach { x => attr = scala.xml.Attribute(null, "href", x.toString, attr) }
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@rel", _) => __obj.rel foreach { x => attr = scala.xml.Attribute(null, "rel", x.toString, attr) }
        case ("@rev", _) => __obj.rev foreach { x => attr = scala.xml.Attribute(null, "rev", x.toString, attr) }
        case ("@title", _) => __obj.title foreach { x => attr = scala.xml.Attribute(null, "title", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.A, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_BrFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Br] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.Br] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("br")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Br] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.Br(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.Br, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Br, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultComgunitfmodel_EmFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Em] with Comgunitfmodel_EnrichedTextGroupFormat {
    override val defaultElementLabel: Option[String] = Some("em")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Em] =
      phrase(optTextRecord ~ 
      safeRep((parsemixedEnrichedTextGroup(node, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Em(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Em, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Em, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_LangFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Lang] with Comgunitfmodel_EnrichedTextGroupFormat {
    override val defaultElementLabel: Option[String] = Some("lang")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Lang] =
      phrase(optTextRecord ~ 
      safeRep((parsemixedEnrichedTextGroup(node, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Lang(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@idsrc").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@idsrc" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Lang, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@idsrc", _) => __obj.idsrc foreach { x => attr = scala.xml.Attribute(null, "idsrc", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Lang, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_PronounceFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Pronounce] with Comgunitfmodel_EnrichedTextGroupFormat {
    override val defaultElementLabel: Option[String] = Some("pronounce")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Pronounce] =
      phrase(optTextRecord ~ 
      safeRep((parsemixedEnrichedTextGroup(node, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Pronounce(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@guide").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@guide" -> _ },
        (node \ "@phonetic").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@phonetic" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Pronounce, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@guide", _) => __obj.guide foreach { x => attr = scala.xml.Attribute(null, "guide", x.toString, attr) }
        case ("@phonetic", _) => __obj.phonetic foreach { x => attr = scala.xml.Attribute(null, "phonetic", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Pronounce, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_QFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Q] with Comgunitfmodel_EnrichedTextGroupFormat {
    override val defaultElementLabel: Option[String] = Some("q")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Q] =
      phrase(optTextRecord ~ 
      safeRep((parsemixedEnrichedTextGroup(node, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Q(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@quote-source").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@quote-source" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Q, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@quote-source", _) => __obj.quoteSource foreach { x => attr = scala.xml.Attribute(null, "quote-source", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Q, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_AddresseeFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Addressee] {
    override val defaultElementLabel: Option[String] = Some("addressee")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Addressee] =
      phrase((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "person")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "function")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "care.of")) ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Addressee(scalaxb.fromXML[com.gu.nitf.model.Person](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[com.gu.nitf.model.FunctionType](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[com.gu.nitf.model.CareOf](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Addressee, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Addressee, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.gu.nitf.model.Person](__obj.person, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("person"), __scope, false),
        __obj.function map { scalaxb.toXML[com.gu.nitf.model.FunctionType](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("function"), __scope, false) } getOrElse {Nil},
        __obj.careOf map { scalaxb.toXML[com.gu.nitf.model.CareOf](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("care.of"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultComgunitfmodel_CareOfFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.CareOf] {
    override val defaultElementLabel: Option[String] = Some("care.of")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.CareOf] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.CareOf(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.CareOf, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.CareOf, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_DeliveryPointFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.DeliveryPoint] {
    override val defaultElementLabel: Option[String] = Some("delivery.point")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.DeliveryPoint] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "br")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Br](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.DeliveryPoint(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@point-code").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@point-code" -> _ },
        (node \ "@code-source").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@code-source" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.DeliveryPoint, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@point-code", _) => __obj.pointCode foreach { x => attr = scala.xml.Attribute(null, "point-code", x.toString, attr) }
        case ("@code-source", _) => __obj.codeSource foreach { x => attr = scala.xml.Attribute(null, "code-source", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.DeliveryPoint, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_PostcodeFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Postcode] {
    override val defaultElementLabel: Option[String] = Some("postcode")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Postcode] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.Postcode(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@code-source").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@code-source" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Postcode, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@code-source", _) => __obj.codeSource foreach { x => attr = scala.xml.Attribute(null, "code-source", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Postcode, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_DeliveryOfficeFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.DeliveryOffice] {
    override val defaultElementLabel: Option[String] = Some("delivery.office")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.DeliveryOffice] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "br")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Br](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.DeliveryOffice(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@office-code").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@office-code" -> _ },
        (node \ "@code-source").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@code-source" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.DeliveryOffice, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@office-code", _) => __obj.officeCode foreach { x => attr = scala.xml.Attribute(null, "office-code", x.toString, attr) }
        case ("@code-source", _) => __obj.codeSource foreach { x => attr = scala.xml.Attribute(null, "code-source", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.DeliveryOffice, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_BodyEndFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.BodyEnd] {
    override val defaultElementLabel: Option[String] = Some("body.end")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.BodyEnd] =
      phrase(opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "tagline")) ~ 
      opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "bibliography")) ^^
      { case p1 ~ p2 =>
      com.gu.nitf.model.BodyEnd(p1.headOption map { scalaxb.fromXML[com.gu.nitf.model.Tagline](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[com.gu.nitf.model.Bibliography](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.BodyEnd, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.BodyEnd, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.tagline map { scalaxb.toXML[com.gu.nitf.model.Tagline](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("tagline"), __scope, false) } getOrElse {Nil},
        __obj.bibliography map { scalaxb.toXML[com.gu.nitf.model.Bibliography](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("bibliography"), __scope, false) } getOrElse {Nil})

  }

  def buildComgunitfmodel_TypeType3Format = new DefaultComgunitfmodel_TypeType3Format {}
  trait DefaultComgunitfmodel_TypeType3Format extends scalaxb.XMLFormat[com.gu.nitf.model.TypeType3] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("type")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.TypeType3 = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("std")) => com.gu.nitf.model.StdValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("pa")) => com.gu.nitf.model.PaValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("npa")) => com.gu.nitf.model.NpaValue

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.TypeType3] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.TypeType3, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultComgunitfmodel_TaglineFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Tagline] with Comgunitfmodel_EnrichedTextGroupFormat {
    override val defaultElementLabel: Option[String] = Some("tagline")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Tagline] =
      phrase(optTextRecord ~ 
      safeRep((parsemixedEnrichedTextGroup(node, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Tagline(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.TypeType3](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[com.gu.nitf.model.TypeType3](scala.xml.Text("std"), scalaxb.ElemName(node) :: stack))) map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Tagline, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@type", _) => if (__obj.typeValue.toString != "std") attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Tagline, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_BibliographyFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Bibliography] {
    override val defaultElementLabel: Option[String] = Some("bibliography")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Bibliography] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.Bibliography(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Bibliography, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Bibliography, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_ClassifierFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.Classifier] {
    override val defaultElementLabel: Option[String] = Some("classifier")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.Classifier] =
      phrase(optTextRecord ~ 
      safeRep(((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "alt-code")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.AltCode](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      com.gu.nitf.model.Classifier(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@idsrc").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@idsrc" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.Classifier, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@type", _) => __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
        case ("@idsrc", _) => __obj.idsrc foreach { x => attr = scala.xml.Attribute(null, "idsrc", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.Classifier, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_NitfTableFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.NitfTable] {
    override val defaultElementLabel: Option[String] = Some("nitf-table")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.NitfTable] =
      phrase((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "nitf-table-metadata")) ~ 
      (((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "table")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Table](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "custom-table")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.CustomTable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "table-reference")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.TableReference](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 ~ p2 =>
      com.gu.nitf.model.NitfTable(scalaxb.fromXML[com.gu.nitf.model.NitfTableMetadata](p1, scalaxb.ElemName(node) :: stack),
        p2,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.NitfTable, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.NitfTable, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[com.gu.nitf.model.NitfTableMetadata](__obj.nitfTableMetadata, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("nitf-table-metadata"), __scope, false),
        (Some(__obj.nitftableoption) map {x => scalaxb.toXML[scalaxb.DataRecord[com.gu.nitf.model.NitfTableOption]](x, x.namespace, x.key, __scope, false)}).get)

  }

  trait DefaultComgunitfmodel_CustomTableFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.CustomTable] {
    override val defaultElementLabel: Option[String] = Some("custom-table")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.CustomTable] =
      phrase(optTextRecord ^^
      { case p1 =>
      com.gu.nitf.model.CustomTable(Seq.concat(p1.toList),
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.CustomTable, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.CustomTable, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultComgunitfmodel_TableReferenceFormat extends scalaxb.XMLFormat[com.gu.nitf.model.TableReference] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.TableReference] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("table-reference")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.TableReference] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.TableReference(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@idref").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@idref" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.TableReference, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@idref", _) => attr = scala.xml.Attribute(null, "idref", __obj.idref.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.TableReference, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  def buildComgunitfmodel_StatusFormat = new DefaultComgunitfmodel_StatusFormat {}
  trait DefaultComgunitfmodel_StatusFormat extends scalaxb.XMLFormat[com.gu.nitf.model.Status] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("status")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.Status = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("pre")) => com.gu.nitf.model.PreValue
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("snap-shot")) => com.gu.nitf.model.SnapShot
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("interim")) => com.gu.nitf.model.Interim
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("final")) => com.gu.nitf.model.Final
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("official")) => com.gu.nitf.model.Official

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.Status] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.Status, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultComgunitfmodel_NitfTableMetadataFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.NitfTableMetadata] {
    override val defaultElementLabel: Option[String] = Some("nitf-table-metadata")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.NitfTableMetadata] =
      phrase(opt(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "nitf-table-summary")) ~ 
      safeRep(((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "nitf-colgroup")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.NitfColgroup](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "nitf-col")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.NitfCol](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 ~ p2 =>
      com.gu.nitf.model.NitfTableMetadata(p1.headOption map { scalaxb.fromXML[com.gu.nitf.model.NitfTableSummary](_, scalaxb.ElemName(node) :: stack) },
        p2,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ },
        (node \ "@subclass").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@subclass" -> _ },
        (node \ "@idsrc").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@idsrc" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ },
        (node \ "@status").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.Status](x, scalaxb.ElemName(node) :: stack)) } map { "@status" -> _ },
        (node \ "@column-count").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@column-count" -> _ },
        (node \ "@row-count").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@row-count" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.NitfTableMetadata, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case ("@subclass", _) => __obj.subclass foreach { x => attr = scala.xml.Attribute(null, "subclass", x.toString, attr) }
        case ("@idsrc", _) => __obj.idsrc foreach { x => attr = scala.xml.Attribute(null, "idsrc", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case ("@status", _) => __obj.status foreach { x => attr = scala.xml.Attribute(null, "status", x.toString, attr) }
        case ("@column-count", _) => __obj.columnCount foreach { x => attr = scala.xml.Attribute(null, "column-count", x.toString, attr) }
        case ("@row-count", _) => __obj.rowCount foreach { x => attr = scala.xml.Attribute(null, "row-count", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.NitfTableMetadata, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.nitfTableSummary map { scalaxb.toXML[com.gu.nitf.model.NitfTableSummary](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("nitf-table-summary"), __scope, false) } getOrElse {Nil},
        __obj.nitftablemetadataoption flatMap { x => scalaxb.toXML[scalaxb.DataRecord[com.gu.nitf.model.NitfTableMetadataOption]](x, x.namespace, x.key, __scope, false) })

  }

  trait DefaultComgunitfmodel_NitfTableSummaryFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.NitfTableSummary] {
    override val defaultElementLabel: Option[String] = Some("nitf-table-summary")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.NitfTableSummary] =
      phrase(safeRep(scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "p")) ^^
      { case p1 =>
      com.gu.nitf.model.NitfTableSummary(p1 map { scalaxb.fromXML[com.gu.nitf.model.P](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@class").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@class" -> _ },
        (node \ "@style").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@style" -> _ },
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@{http://www.w3.org/XML/1998/namespace}lang" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.NitfTableSummary, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@class", _) => __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
        case ("@style", _) => __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
        case ("@{http://www.w3.org/XML/1998/namespace}lang", _) => __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.NitfTableSummary, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.p flatMap { scalaxb.toXML[com.gu.nitf.model.P](_, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("p"), __scope, false) })

  }

  trait DefaultComgunitfmodel_NitfColgroupFormat extends scalaxb.ElemNameParser[com.gu.nitf.model.NitfColgroup] {
    override val defaultElementLabel: Option[String] = Some("nitf-colgroup")
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.gu.nitf.model.NitfColgroup] =
      phrase(safeRep(((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "nitf-col"))) ^^ 
        { case p1 => com.gu.nitf.model.NitfColgroupSequence1(scalaxb.fromXML[com.gu.nitf.model.NitfCol](p1, scalaxb.ElemName(node) :: stack)) }) ^^
      { case p1 =>
      com.gu.nitf.model.NitfColgroup(p1,
        scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@idsrc").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@idsrc" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ },
        (node \ "@occurrences").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@occurrences" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: com.gu.nitf.model.NitfColgroup, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@idsrc", _) => __obj.idsrc foreach { x => attr = scala.xml.Attribute(null, "idsrc", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case ("@occurrences", _) => __obj.occurrences foreach { x => attr = scala.xml.Attribute(null, "occurrences", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.NitfColgroup, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.nitfcolgroupsequence1 flatMap { scalaxb.toXML[com.gu.nitf.model.NitfColgroupSequence1](_, None, Some("nitfcolgroupsequence1"), __scope, false) })

  }

  trait DefaultComgunitfmodel_NitfColgroupSequence1Format extends scalaxb.XMLFormat[com.gu.nitf.model.NitfColgroupSequence1] {
    final override def defaultElementLabel: Option[String] = None  // sequences have no label
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.NitfColgroupSequence1] = Left("don't call me.")
    
    def writes(__obj: com.gu.nitf.model.NitfColgroupSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scalaxb.toXML[com.gu.nitf.model.NitfCol](__obj.nitfCol, Some("http://iptc.org/std/nitf/2006-03-01/"), Some("nitf-col"), __scope, false)


  }

  def buildComgunitfmodel_DataTypeFormat = new DefaultComgunitfmodel_DataTypeFormat {}
  trait DefaultComgunitfmodel_DataTypeFormat extends scalaxb.XMLFormat[com.gu.nitf.model.DataType] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("data-type")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): com.gu.nitf.model.DataType = scalaxb.fromXML[String](scala.xml.Text(value)) match {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("text")) => com.gu.nitf.model.Text
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("number")) => com.gu.nitf.model.Number
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("graphic")) => com.gu.nitf.model.Graphic
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("other")) => com.gu.nitf.model.OtherValue3

    }

    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.DataType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.gu.nitf.model.DataType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel orElse defaultElementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultComgunitfmodel_NitfColFormat extends scalaxb.XMLFormat[com.gu.nitf.model.NitfCol] with scalaxb.CanWriteChildNodes[com.gu.nitf.model.NitfCol] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    override val defaultElementLabel: Option[String] = Some("nitf-col")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.NitfCol] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.NitfCol(scala.collection.immutable.ListMap(List(
        (node \ "@id").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@id" -> _ },
        (node \ "@idsrc").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@idsrc" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ },
        (node \ "@occurrences").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@occurrences" -> _ },
        (node \ "@data-type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[com.gu.nitf.model.DataType](x, scalaxb.ElemName(node) :: stack)) } map { "@data-type" -> _ },
        (node \ "@data-format").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@data-format" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.gu.nitf.model.NitfCol, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@id", _) => __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
        case ("@idsrc", _) => __obj.idsrc foreach { x => attr = scala.xml.Attribute(null, "idsrc", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case ("@occurrences", _) => __obj.occurrences foreach { x => attr = scala.xml.Attribute(null, "occurrences", x.toString, attr) }
        case ("@data-type", _) => __obj.dataType foreach { x => attr = scala.xml.Attribute(null, "data-type", x.toString, attr) }
        case ("@data-format", _) => __obj.dataFormat foreach { x => attr = scala.xml.Attribute(null, "data-format", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: com.gu.nitf.model.NitfCol, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }


  trait Comgunitfmodel_BlockContentGroupFormat extends scalaxb.AnyElemNameParser {
    def parseBlockContentGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.DataRecord[com.gu.nitf.model.BlockContentOption]] =
      (((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "p")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.P](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "hl2")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Hl2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "table")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Table](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "nitf-table")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.NitfTable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "media")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Media](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "ol")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Ol](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "ul")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Ul](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "dl")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Dl](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "bq")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Bq](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "fn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Fn](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "note")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Note](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "pre")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Pre](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "hr")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Hr](x, scalaxb.ElemName(node) :: stack)))))
  
    def parseBlockContentGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[com.gu.nitf.model.BlockContentOption]] =
      (((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "p")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.P](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "hl2")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Hl2](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "table")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Table](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "nitf-table")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.NitfTable](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "media")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Media](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "ol")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Ol](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "ul")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Ul](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "dl")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Dl](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "bq")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Bq](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "fn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Fn](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "note")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Note](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "pre")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Pre](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "hr")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Hr](x, scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedBlockContentGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "p")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.P](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "hl2")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Hl2](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "table")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Table](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "nitf-table")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.NitfTable](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "media")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Media](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "ol")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Ol](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "ul")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Ul](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "dl")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Dl](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "bq")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Bq](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "fn")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Fn](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "note")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Note](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "pre")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Pre](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "hr")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Hr](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }


  trait Comgunitfmodel_EnrichedTextGroupFormat extends scalaxb.AnyElemNameParser {
    def parseEnrichedTextGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.DataRecord[com.gu.nitf.model.EnrichedTextOption]] =
      (((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "chron")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Chron](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "classifier")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Classifier](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "copyrite")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Copyrite](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "event")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Event](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "function")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.FunctionType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "location")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Location](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "money")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Money](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "num")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Num](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "object.title")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.ObjectTitle](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "org")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Org](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "person")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Person](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "postaddr")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Postaddr](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "virtloc")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Virtloc](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "a")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.A](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "br")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Br](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "em")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Em](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "lang")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Lang](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "pronounce")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Pronounce](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "q")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Q](x, scalaxb.ElemName(node) :: stack)))))
  
    def parseEnrichedTextGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[com.gu.nitf.model.EnrichedTextOption]] =
      (((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "chron")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Chron](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "classifier")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Classifier](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "copyrite")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Copyrite](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "event")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Event](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "function")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.FunctionType](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "location")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Location](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "money")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Money](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "num")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Num](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "object.title")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.ObjectTitle](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "org")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Org](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "person")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Person](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "postaddr")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Postaddr](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "virtloc")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Virtloc](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "a")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.A](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "br")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Br](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "em")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Em](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "lang")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Lang](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "pronounce")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Pronounce](x, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "q")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Q](x, scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedEnrichedTextGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "chron")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Chron](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "classifier")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Classifier](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "copyrite")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Copyrite](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "event")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Event](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "function")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.FunctionType](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "location")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Location](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "money")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Money](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "num")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Num](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "object.title")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.ObjectTitle](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "org")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Org](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "person")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Person](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "postaddr")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Postaddr](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "virtloc")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Virtloc](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "a")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.A](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "br")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Br](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "em")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Em](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "lang")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Lang](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "pronounce")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Pronounce](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://iptc.org/std/nitf/2006-03-01/"), "q")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.gu.nitf.model.Q](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }

  trait DefaultComgunitfmodel_CellVAlignFormat extends scalaxb.AttributeGroupFormat[com.gu.nitf.model.CellVAlign] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.CellVAlign] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.CellVAlign((node \ "@valign").headOption map { scalaxb.fromXML[com.gu.nitf.model.Valign](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.gu.nitf.model.CellVAlign, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.valign foreach { x => attr = scala.xml.Attribute(null, "valign", x.toString, attr) }
      attr
    }
  }

  trait DefaultComgunitfmodel_CommonNITFAttributesFormat extends scalaxb.AttributeGroupFormat[com.gu.nitf.model.CommonNITFAttributes] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.CommonNITFAttributes] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.CommonNITFAttributes((node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@class").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@style").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.gu.nitf.model.CommonNITFAttributes, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
    __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
    __obj.style foreach { x => attr = scala.xml.Attribute(null, "style", x.toString, attr) }
    __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
      attr
    }
  }

  trait DefaultComgunitfmodel_GlobalNITFAttributesFormat extends scalaxb.AttributeGroupFormat[com.gu.nitf.model.GlobalNITFAttributes] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.GlobalNITFAttributes] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.GlobalNITFAttributes((node \ "@id").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.gu.nitf.model.GlobalNITFAttributes, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.id foreach { x => attr = scala.xml.Attribute(null, "id", x.toString, attr) }
      attr
    }
  }

  trait DefaultComgunitfmodel_CellAlignFormat extends scalaxb.AttributeGroupFormat[com.gu.nitf.model.CellAlign] {
    val targetNamespace: Option[String] = Some("http://iptc.org/std/nitf/2006-03-01/")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.gu.nitf.model.CellAlign] = seq match {
      case node: scala.xml.Node => Right(com.gu.nitf.model.CellAlign((node \ "@align").headOption map { scalaxb.fromXML[com.gu.nitf.model.Align](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@char").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
      (node \ "@charoff").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def toAttribute(__obj: com.gu.nitf.model.CellAlign, __attr: scala.xml.MetaData, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = __attr
      __obj.align foreach { x => attr = scala.xml.Attribute(null, "align", x.toString, attr) }
    __obj.char foreach { x => attr = scala.xml.Attribute(null, "char", x.toString, attr) }
    __obj.charoff foreach { x => attr = scala.xml.Attribute(null, "charoff", x.toString, attr) }
      attr
    }
  }


}

